var documenterSearchIndex = {"docs":
[{"location":"dingemans/#dingemans","page":"Experimental Data","title":"Dingemans Experiment","text":"","category":"section"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"The Dingemans experiment provides a classic benchmark for validating dispersive shallow water models against experimental data. This experiment, conducted by Dingemans in 1994, simulates waves generated by a wave maker that propagate over a varying underwater topography (bathymetry).","category":"page"},{"location":"dingemans/#Experimental-Setup","page":"Experimental Data","title":"Experimental Setup","text":"","category":"section"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"The experiment features waves with a small amplitude (A = 0.02) that encounter a trapezoidal bathymetry profile. The bottom topography starts flat, then rises to form an underwater \"hill\" before descending back to the original depth. This setup tests how well different dispersive wave models can capture the complex wave transformations that occur when waves interact with varying bottom topography.","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"The bathymetry profile consists of:","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"A flat section from the wave maker to x = 11.01\nA linearly increasing slope from x = 11.01 to x = 23.04 (maximum height of 0.6)\nA flat plateau from x = 23.04 to x = 27.04  \nA linearly decreasing slope from x = 27.04 to x = 33.07\nA flat section beyond x = 33.07","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"This configuration allows researchers to study wave shoaling (changes in wave characteristics due to depth variations), which is crucial for understanding coastal wave dynamics.","category":"page"},{"location":"dingemans/#Numerical-Simulation","page":"Experimental Data","title":"Numerical Simulation","text":"","category":"section"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"Let's implement the Dingemans experiment and compare the performance of different dispersive shallow water models available in DispersiveShallowWater.jl.","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"First, we load the necessary packages:","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"using DispersiveShallowWater, OrdinaryDiffEqTsit5, Plots","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"Next, we set up the different equation systems we want to compare:","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"# BBM-BBM equations with variable bathymetry\nbbm = BBMBBMEquations1D(bathymetry_type = bathymetry_variable,\n                        gravity = 9.81, eta0 = 0.0)\n\n# Svärd-Kalisch equations with specific parameter set\nsk = SvaerdKalischEquations1D(gravity = 9.81, eta0 = 0.8, alpha = 0.0,\n                              beta = 0.27946992481203003, gamma = 0.0521077694235589)\n\n# Serre-Green-Naghdi equations with variable bathymetry  \nsgn = SerreGreenNaghdiEquations1D(bathymetry_type = bathymetry_variable,\n                                  gravity = 9.81)\n\n# Hyperbolic approximation of Serre-Green-Naghdi equations\nhysgn = HyperbolicSerreGreenNaghdiEquations1D(bathymetry_type = bathymetry_mild_slope,\n                                              lambda = 500.0, gravity = 9.81)\nnothing # hide","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"The initial condition initial_condition_dingemans automatically sets up the trapezoidal bathymetry and initial wave field.","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"initial_condition = initial_condition_dingemans\nboundary_conditions = boundary_condition_periodic\nnothing # hide","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"We create a computational domain that's large enough to contain the entire experimental setup, with the wave maker positioned appropriately:","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"coordinates_min = -138.0\ncoordinates_max = 46.0\nN = 512\nmesh = Mesh1D(coordinates_min, coordinates_max, N)\nnothing # hide","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"For the spatial discretization, we use fourth-order accurate summation-by-parts operators:","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"accuracy_order = 4\nsolver = Solver(mesh, accuracy_order)\nnothing # hide","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"We set up the time integration parameters. The experiment runs for a relatively long time to observe the full wave propagation and interaction with the bathymetry:","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"tspan = (0.0, 70.0)\nsaveat = range(tspan..., length = 500)\nnothing # hide","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"Now we create semidiscretizations for each equation system. Each semidiscretization bundles the mesh, equations, initial condition, solver, and boundary conditions:","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"semi_bbm = Semidiscretization(mesh, bbm, initial_condition, solver,\n                              boundary_conditions = boundary_conditions)\nsemi_sk = Semidiscretization(mesh, sk, initial_condition, solver,\n                             boundary_conditions = boundary_conditions)\nsemi_sgn = Semidiscretization(mesh, sgn, initial_condition, solver,\n                              boundary_conditions = boundary_conditions)\nsemi_hysgn = Semidiscretization(mesh, hysgn, initial_condition, solver,\n                                boundary_conditions = boundary_conditions)\nnothing # hide","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"We convert each semidiscretization to an ODE problem and solve using the Tsit5 time integrator:","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"ode_bbm = semidiscretize(semi_bbm, tspan)\node_sk = semidiscretize(semi_sk, tspan)\node_sgn = semidiscretize(semi_sgn, tspan)\node_hysgn = semidiscretize(semi_hysgn, tspan)\n\nsol_bbm = solve(ode_bbm, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n                save_everystep = false, saveat = saveat)\nsol_sk = solve(ode_sk, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n               save_everystep = false, saveat = saveat)\nsol_sgn = solve(ode_sgn, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n                save_everystep = false, saveat = saveat)\nsol_hysgn = solve(ode_hysgn, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n                  save_everystep = false, saveat = saveat)\nnothing # hide","category":"page"},{"location":"dingemans/#Visualization-and-Comparison","page":"Experimental Data","title":"Visualization and Comparison","text":"","category":"section"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"For proper comparison, we need to account for the fact that the BBM-BBM equations use a different reference level (η₀ = 0) compared to the other equations. We create a custom conversion function which allows us to easily shift the BBM-BBM results:","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"# BBM-BBM equations need to be translated vertically for comparison\nshifted_waterheight(q, equations) = waterheight_total(q, equations) + 0.8\nDispersiveShallowWater.varnames(::typeof(shifted_waterheight), equations) = (\"η\",)","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"Finally, we create comparison plots at four different time instances to observe how the waves evolve as they interact with the bathymetry:","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"# Define parameters\ntimes = [14.0, 28.0, 42.0, 70.0]\ny_limits = (-0.03, 0.87)\n\n# Model configurations: (semidiscretization, solution, label, conversion_function)\nmodels = [\n    (semi_bbm, sol_bbm, \"BBM\", shifted_waterheight),\n    (semi_sk, sol_sk, \"Svärd-Kalisch\", waterheight_total),\n    (semi_sgn, sol_sgn, \"Serre-Green-Naghdi\", waterheight_total),\n    (semi_hysgn, sol_hysgn, \"Hyperbolic Serre-Green-Naghdi\", waterheight_total)\n]\n\n# Create snapshot plots for each time\nsnapshot_plots = []\nfor time_val in times\n    step_idx = argmin(abs.(saveat .- time_val)) # get the closed point to the time_val\n    p = plot(title = \"t = $time_val\", ylims = y_limits)\n    \n    for (i, (semi, sol, label, conversion)) in enumerate(models)\n        plot!(p, semi => sol, \n              step = step_idx,\n              label = label,\n              conversion = conversion,\n              plot_bathymetry = true,\n              legend = false,\n              suptitle = \"Dingemans at t = $(time_val)\",\n              title = \"\"\n              )\n    end\n    \n    push!(snapshot_plots, p)\nend\n\n# Create legend plot \nlegend_plot = plot(legend=:top, framestyle = :none, legendfontsize = 11)\n\nfor (_, _, label, _) in models\n    plot!(legend_plot, [], [], label = label)\nend\nplot!(legend_plot, [], [], label = \"Bathymetry\", color = :black)\n\n# Combine all plots\nall_plots = [snapshot_plots..., legend_plot]\nplot(all_plots..., \n     size = (900, 800), \n     layout = @layout([a b; c d; e]),\n)\nsavefig(\"dingemans_comparison.png\") # hide\nnothing # hide","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"(Image: Dingemans comparison)","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"The results show how different dispersive wave models capture the wave evolution over the trapezoidal bathymetry.","category":"page"},{"location":"dingemans/#overview-plain-program-dingemans","page":"Experimental Data","title":"Plain program","text":"","category":"section"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"Here follows a version of the program without any comments.","category":"page"},{"location":"dingemans/","page":"Experimental Data","title":"Experimental Data","text":"using DispersiveShallowWater, OrdinaryDiffEqTsit5, Plots\n\n# BBM-BBM equations with variable bathymetry\nbbm = BBMBBMEquations1D(bathymetry_type = bathymetry_variable,\n                        gravity = 9.81, eta0 = 0.0)\n\n# Svärd-Kalisch equations with specific parameter set\nsk = SvaerdKalischEquations1D(gravity = 9.81, eta0 = 0.8, alpha = 0.0,\n                              beta = 0.27946992481203003, gamma = 0.0521077694235589)\n\n# Serre-Green-Naghdi equations with variable bathymetry  \nsgn = SerreGreenNaghdiEquations1D(bathymetry_type = bathymetry_variable,\n                                  gravity = 9.81)\n\n# Hyperbolic approximation of Serre-Green-Naghdi equations\nhysgn = HyperbolicSerreGreenNaghdiEquations1D(bathymetry_type = bathymetry_mild_slope,\n                                              lambda = 500.0, gravity = 9.81)\n\ninitial_condition = initial_condition_dingemans\nboundary_conditions = boundary_condition_periodic\n\ncoordinates_min = -138.0\ncoordinates_max = 46.0\nN = 512\nmesh = Mesh1D(coordinates_min, coordinates_max, N)\n\naccuracy_order = 4\nsolver = Solver(mesh, accuracy_order)\n\ntspan = (0.0, 70.0)\nsaveat = range(tspan..., length = 500)\n\nsemi_bbm = Semidiscretization(mesh, bbm, initial_condition, solver,\n                              boundary_conditions = boundary_conditions)\nsemi_sk = Semidiscretization(mesh, sk, initial_condition, solver,\n                             boundary_conditions = boundary_conditions)\nsemi_sgn = Semidiscretization(mesh, sgn, initial_condition, solver,\n                              boundary_conditions = boundary_conditions)\nsemi_hysgn = Semidiscretization(mesh, hysgn, initial_condition, solver,\n                                boundary_conditions = boundary_conditions)\n\node_bbm = semidiscretize(semi_bbm, tspan)\node_sk = semidiscretize(semi_sk, tspan)\node_sgn = semidiscretize(semi_sgn, tspan)\node_hysgn = semidiscretize(semi_hysgn, tspan)\n\nsol_bbm = solve(ode_bbm, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n                save_everystep = false, saveat = saveat)\nsol_sk = solve(ode_sk, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n               save_everystep = false, saveat = saveat)\nsol_sgn = solve(ode_sgn, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n                save_everystep = false, saveat = saveat)\nsol_hysgn = solve(ode_hysgn, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n                  save_everystep = false, saveat = saveat)\n\n# BBM-BBM equations need to be translated vertically for comparison\nshifted_waterheight(q, equations) = waterheight_total(q, equations) + 0.8\nDispersiveShallowWater.varnames(::typeof(shifted_waterheight), equations) = (\"η\",)\n\n# Define parameters\ntimes = [14.0, 28.0, 42.0, 70.0]\ny_limits = (-0.03, 0.87)\n\n# Model configurations: (semidiscretization, solution, label, conversion_function)\nmodels = [\n    (semi_bbm, sol_bbm, \"BBM\", shifted_waterheight),\n    (semi_sk, sol_sk, \"Svärd-Kalisch\", waterheight_total),\n    (semi_sgn, sol_sgn, \"Serre-Green-Naghdi\", waterheight_total),\n    (semi_hysgn, sol_hysgn, \"Hyperbolic Serre-Green-Naghdi\", waterheight_total)\n]\n\n# Create snapshot plots for each time\nsnapshot_plots = []\nfor time_val in times\n    step_idx = argmin(abs.(saveat .- time_val)) # get the closed point to the time_val\n    p = plot(title = \"t = $time_val\", ylims = y_limits)\n\n    for (i, (semi, sol, label, conversion)) in enumerate(models)\n        plot!(p, semi => sol,\n              step = step_idx,\n              label = label,\n              conversion = conversion,\n              plot_bathymetry = true,\n              legend = false,\n              suptitle = \"Dingemans at t = $(time_val)\",\n              title = \"\")\n    end\n\n    push!(snapshot_plots, p)\nend\n\n# Create legend plot \nlegend_plot = plot(legend = :top, framestyle = :none, legendfontsize = 11)\n\nfor (_, _, label, _) in models\n    plot!(legend_plot, [], [], label = label)\nend\nplot!(legend_plot, [], [], label = \"Bathymetry\", color = :black)\n\n# Combine all plots\nall_plots = [snapshot_plots..., legend_plot]\nplot(all_plots...,\n     size = (900, 800),\n     layout = @layout([a b; c d; e]))","category":"page"},{"location":"contributing/#Contributing","page":"Contributing","title":"Contributing","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"DispersiveShallowWater.jl is an open-source project and we are very happy to accept contributions from the community. Please feel free to open issues or submit patches (preferably as pull requests) any time.","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"DispersiveShallowWater.jl and its contributions are licensed under the MIT license (see License). As a contributor, you certify that all your contributions are in conformance with the Developer Certificate of Origin (Version 1.1), which is reproduced below.","category":"page"},{"location":"contributing/#Developer-Certificate-of-Origin-(Version-1.1)","page":"Contributing","title":"Developer Certificate of Origin (Version 1.1)","text":"","category":"section"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"The following text was taken from https://developercertificate.org:","category":"page"},{"location":"contributing/","page":"Contributing","title":"Contributing","text":"Developer Certificate of Origin\nVersion 1.1\n\nCopyright (C) 2004, 2006 The Linux Foundation and its contributors.\n1 Letterman Drive\nSuite D4700\nSan Francisco, CA, 94129\n\nEveryone is permitted to copy and distribute verbatim copies of this\nlicense document, but changing it is not allowed.\n\n\nDeveloper's Certificate of Origin 1.1\n\nBy making a contribution to this project, I certify that:\n\n(a) The contribution was created in whole or in part by me and I\n    have the right to submit it under the open source license\n    indicated in the file; or\n\n(b) The contribution is based upon previous work that, to the best\n    of my knowledge, is covered under an appropriate open source\n    license and I have the right under that license to submit that\n    work with modifications, whether created in whole or in part\n    by me, under the same open source license (unless I am\n    permitted to submit under a different license), as indicated\n    in the file; or\n\n(c) The contribution was provided directly to me by some other\n    person who certified (a), (b) or (c) and I have not modified\n    it.\n\n(d) I understand and agree that this project and the contribution\n    are public and that a record of the contribution (including all\n    personal information I submit with it, including my sign-off) is\n    maintained indefinitely and may be redistributed consistent with\n    this project or the open source license(s) involved.","category":"page"},{"location":"development/#Development","page":"Development","title":"Development","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you have any suggestions or ideas for improvements or new features, we are pleased to accept and discuss issues or if you are willing to contribute, feel free to open a pull request, even if it is only fixing a typo or improving the docs.","category":"page"},{"location":"development/#Changing-DispersiveShallowWater.jl-and-running-it-locally","page":"Development","title":"Changing DispersiveShallowWater.jl and running it locally","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you plan to edit DispersiveShallowWater.jl, you first need to clone a local copy of the repository, which can be done by using git. It is recommended that you create a project, e.g. call it run, inside the repository, where you can add packages that you use during executing and testing DispersiveShallowWater.jl, but are not needed by DispersiveShallowWater.jl. This way you can keep the Project.toml of the main repository clean. To do so, you can execute the following lines in a terminal:","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"git clone https://github.com/NumericalMathematics/DispersiveShallowWater.jl.git\ncd DispersiveShallowWater\nmkdir run\ncd run\njulia --project=. -e 'using Pkg; Pkg.develop(PackageSpec(path=\"..\"))' # Install local DispersiveShallowWater.jl clone\njulia --project=. -e 'using Pkg; Pkg.add([\"OrdinaryDiffEqTsit5\", \"Plots\", \"SummationByPartsOperators\"])' # Install additional packages","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"If you use other packages for executing DispersiveShallowWater.jl, you can add them to the project in the run directory in an analogous way as above. To use the Julia project within run, be sure to start the Julia REPL by","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=.","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"if already inside the the run directory or julia --project=run if in the main directory of the repo.","category":"page"},{"location":"development/#Preview-of-the-documentation","page":"Development","title":"Preview of the documentation","text":"","category":"section"},{"location":"development/","page":"Development","title":"Development","text":"If you want to build the documentation locally, you can run","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs -e 'using Pkg; Pkg.develop(PackageSpec(path=pwd())); Pkg.instantiate()'","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"once from the DispersiveShallowWater.jl main directory to tell Documenter.jl to build the documentation of your local clone. To build the documentation, run","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"julia --project=docs --color=yes docs/make.jl","category":"page"},{"location":"development/","page":"Development","title":"Development","text":"The resulting .html files can then be found in docs/build/ and you can look at them by opening them in a browser. For pull requests from the main repository (i.e. not from a fork), the documentation is automatically built and can be previewed under https://NumericalMathematics.github.io/DispersiveShallowWater.jl/previews/PRXXX/ where XXX is the number of the pull request.","category":"page"},{"location":"dispersion/#Dispersive-properties-of-the-equations","page":"Dispersion","title":"Dispersive properties of the equations","text":"","category":"section"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"The equations implemented in DispersiveShallowWater.jl describe the propagation of waves in a shallow water system. The equations are dispersive, meaning that the phase speed of the waves depends on their wavelength. This is in contrast to non-dispersive waves, where all waves travel at the same speed, such as the solution to the shallow water equations linearized around a state with vanishing velocity and constant water height h_0. In this case the phase speed is constantly given by c_0 = sqrtg h_0, where g is the acceleration due to gravity and h_0 is a reference water height.","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"The linear dispersion relation of a wave equation describes the relationship between the angular frequency omega and the wavenumber k of a wave. The angular frequency is related to the period T of the wave by omega = 2pi  T and the wavenumber is related to the wavelength lambda by k = 2pi  lambda. The simple case of just one wave traveling with speed c is a harmonic (or plane wave) solution of the form eta(t x) = mathrme^mathrmi(k x - omega t) with c = omega  k. The linear dispersion relation of a wave equation is then derived by substituting this solution into a linearized version of the equation and solving for omega in terms of k.","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"Since all the equations implemented in DispersiveShallowWater.jl are approximations to the full wave equations given by the Euler equations, their dispersion relations do not describe the exact speed of waves, but only an approximation to it, where the approximation usually becomes better for longer wavelengths. The dispersion relation of the full wave system is given by","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"omega(k) = pm sqrtg k tanh(h_0 k)","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"In DispersiveShallowWater.jl, we can investigate the dispersion relations of the different equations. Let us plot the wave speeds of the different equations normalized by the shallow water wave speed c_0 as a function of the wave number. We pick a reference water height of h_0 = 08 and gravitational acceleration of g = 981.","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"using DispersiveShallowWater\nusing Plots\n\neta0 = 0.0\nreference_height() = 0.8\nh0 = reference_height()\ng = 9.81\ndisp_rel = LinearDispersionRelation(h0)\nk = 0.01:0.01:5.0\n\neuler = EulerEquations1D(; gravity = g, eta0 = eta0)\nc_euler = wave_speed.(disp_rel, euler, k; normalize = true)\nplot(k, c_euler, label = \"Euler\", xlabel = \"k\", ylabel = \"c / c_0\", legend = :topright, yrange = (-0.1, 1.1))\n\nkdv = KdVEquation1D(; gravity = g, eta0 = eta0, D = h0)\nc_kdv = wave_speed.(disp_rel, kdv, k; normalize = true)\nplot!(k, c_kdv, label = \"KdV\")\n\nbbm = BBMEquation1D(; gravity = g, eta0 = eta0, D = h0)\nc_bbm = wave_speed.(disp_rel, bbm, k; normalize = true)\nplot!(k, c_bbm, label = \"BBM\")\n\n# Optimized set 4 in the preprint\nsk = SvaerdKalischEquations1D(; gravity = g, eta0 = eta0,\n                              alpha = 0.0, beta = 0.2308939393939394, gamma = 0.04034343434343434)\nc_sk = wave_speed.(disp_rel, sk, k; normalize = true)\nplot!(k, c_sk, label = \"Svärd-Kalisch\")\n\nsgn = SerreGreenNaghdiEquations1D(; gravity = g, eta0 = eta0)\nc_sgn = wave_speed.(disp_rel, sgn, k; normalize = true)\nplot!(k, c_sgn, label = \"Serre-Green-Naghdi\")\n\nsavefig(\"dispersion_relations.png\") # hide\nnothing # hide","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"(Image: dispersion relations)","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"To verify that the wave speed predicted by the dispersion relation is indeed the observed one, let us simulate a simple wave traveling in a domain with periodic boundary conditions. We initialize the wave as a traveling wave for the Euler equations by using the dispersion relation. As an example we solve the problem with the Svärd-Kalisch equations.","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"using OrdinaryDiffEqTsit5\nusing Printf\n\nequations = sk\nwave_number() = 3.0\nfrequency(k) = disp_rel(euler, k)\n\nfunction initial_condition_traveling_wave(x, t, equations, mesh)\n    k = wave_number()\n    omega = frequency(k)\n    h0 = reference_height()\n    A = 0.02\n    h = A * cos(k * x - omega * t)\n    v = sqrt(equations.gravity / k * tanh(k * h0)) * h / h0\n    eta = h + equations.eta0\n    D = h0\n    return SVector(eta, v, D)\nend\n\nk = wave_number()\ncoordinates_min = 0\ncoordinates_max = 10 * pi / k # five waves (wave length = 2pi/k)\nN = 512\nmesh = Mesh1D(coordinates_min, coordinates_max, N)\n\n# create solver with periodic SBP operators of accuracy order 4\naccuracy_order = 4\nsolver = Solver(mesh, accuracy_order)\n\n# semidiscretization holds all the necessary data structures for the spatial discretization\nsemi = Semidiscretization(mesh, equations, initial_condition_traveling_wave, solver,\n                          boundary_conditions = boundary_condition_periodic)\n\ntspan = (0.0, 3.0)\node = semidiscretize(semi, tspan)\n\nsaveat = range(tspan..., length = 201)\nsol = solve(ode, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n            save_everystep = false, saveat = saveat, tstops = saveat)\n\nx = 0.2 * (coordinates_max - coordinates_min)\nc_euler = wave_speed(disp_rel, euler, k)\nc = wave_speed(disp_rel, equations, k)\nanim = @animate for step in eachindex(sol.u)\n    t = sol.t[step]\n    x_t_euler = x + c_euler * t\n    x_t = x + c * t\n    index = argmin(abs.(DispersiveShallowWater.grid(semi) .- x_t))\n    scatter([x_t_euler], [initial_condition_traveling_wave(x_t_euler, t, euler, mesh)],\n            color = :blue, label = nothing)\n    eta, = sol.u[step].x\n    scatter!([x_t], [eta[index]],\n             color = :green, label = nothing)\n    plot!(semi => sol, plot_initial = true, plot_bathymetry = false,\n          conversion = waterheight_total, step = step, legend = :topleft, linewidth = 2,\n          plot_title = @sprintf(\"t = %.3f\", t), yrange = (eta0 - 0.03, eta0 + 0.03),\n          linestyles = [:solid :dot], labels = [\"Euler\" \"Svärd-Kalisch\"],\n          color = [:blue :green])\nend\ngif(anim, \"traveling_waves.gif\", fps = 25)\n\nnothing # hide","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"(Image: traveling waves)","category":"page"},{"location":"dispersion/","page":"Dispersion","title":"Dispersion","text":"The dots in the movie show that the wave speed predicted by the dispersion relation is indeed the same as the one obtained by numerically solving the equations. As expected from the plot above the wave speed of the Svärd-Kalisch equations is a bit faster than the correct one, which is due to the approximation made in the equations.","category":"page"},{"location":"basic_example/#Basic-Example","page":"Basic Example","title":"Basic Example","text":"","category":"section"},{"location":"basic_example/#Introduction","page":"Basic Example","title":"Introduction","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"In this tutorial we describe how to numerically solve the BBM-BBM (Benjamin-Bona-Mahony) equations with variable bottom topography in one dimension. The equations describe a dispersive shallow water model, i.e. they extend the well-known shallow water equations in the sense that dispersion is modeled. The shallow water equations are a system of first order hyperbolic partial differential equations that can be written in the form of a balance law. In contrast, the BBM-BBM equations additionally include third-order mixed derivatives. In primitive variables q = (eta v) they can be written as:","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"beginaligned\n  eta_t + ((eta + D)v)_x - frac16(D^2eta_xt)_x = 0\n  v_t + geta_x + left(frac12v^2right)_x - frac16(D^2v_t)_xx = 0\nendaligned","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"All equations in DispersiveShallowWater.jl follow the same variable conventions: eta = h + b describes the total water height, h the water height above the bottom topography (bathymetry), b = eta_0 - D the bathymetry, and v the velocity in horizontal direction. The reference water height eta_0 (also called still water height) and gravitational acceleration g are used consistently across all equations. For the BBM-BBM equations specifically, eta_0 is typically set to 0.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"A sketch of the water height and bathymetry can be found below.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"(Image: water height and bathymetry)","category":"page"},{"location":"basic_example/#basic_example","page":"Basic Example","title":"Getting started","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"In order to conduct a numerical simulation with DispersiveShallowWater.jl, we perform the following steps.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"First, we load the necessary libraries:","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"using DispersiveShallowWater, OrdinaryDiffEqTsit5","category":"page"},{"location":"basic_example/#Define-physical-setup","page":"Basic Example","title":"Define physical setup","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"As a first step of a numerical simulation, we define the physical setup we want to solve. This includes the set of equations, potentially including physical parameters, initial and boundary conditions as well as the domain. In the following example, the initial condition describes a traveling wave that moves towards a beach, which is modeled by a linearly increasing bathymetry.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"equations = BBMBBMEquations1D(bathymetry_type = bathymetry_variable, gravity = 9.81)\n\nfunction initial_condition_shoaling(x, t, equations::BBMBBMEquations1D, mesh)\n    A = 0.07 # amplitude of wave\n    x0 = -30 # initial center\n    eta = A * exp(-0.1*(x - x0)^2)\n    v = 0\n    D = x <= 0.0 ? 0.7 : 0.7 - 1/50 * x\n    return SVector(eta, v, D)\nend\n\ninitial_condition = initial_condition_shoaling\nboundary_conditions = boundary_condition_periodic\n\ncoordinates_min = -130.0\ncoordinates_max = 20.0\nN = 512\nmesh = Mesh1D(coordinates_min, coordinates_max, N)","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"The first line specifies that we want to solve the BBM-BBM equations with variable bathymetry using a gravitational acceleration of g = 981. Afterwards, we define the initial condition, which is described as a function with the spatial variable x, the time t, the equations, and a mesh as parameters.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"If an analytical solution is available, the time variable t can be used, and the initial condition can serve as an analytical solution to be compared with the numerical solution. Otherwise, you can just keep the time variable unused.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"An initial condition in DispersiveShallowWater.jl is supposed to return an SVector holding the values for each of the unknown variables. Since the bathymetry is treated as a variable (with time derivative 0) for convenience, we need to provide the value for the primitive variables eta and v as well as for D.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"Next, we choose periodic boundary conditions. DispersiveShallowWater.jl also supports reflecting boundary conditions for some but not all equations. For more information see the Dispersive Shallow Water Models overview.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"Lastly, we define the physical domain as the interval from -130 to 20 and we choose 512 nodes. The mesh is always homogeneous, i.e. the distance between consecutive nodes is constant. We choose the left boundary very far to the left in order to avoid interactions between left- and right-traveling waves. This prevents unwanted wave interference that could occur when waves wrap around due to the periodic boundary conditions.","category":"page"},{"location":"basic_example/#Define-numerical-solver","page":"Basic Example","title":"Define numerical solver","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"In the next step, we build a Semidiscretization that bundles all ingredients for the spatial discretization of the model. Especially, we need to define a Solver. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"The simplest way to define a solver when working with boundary_condition_periodic is to call the constructor by providing the mesh and a desired order of accuracy.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"In the following example, we use an accuracy order of 4. The default constructor simply creates periodic first-, second-, and third-derivative central finite difference summation-by-parts (SBP) operators of the provided order of accuracy. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"How to use other summation-by-parts operators, is described in the section on how to customize the solver. Note that for non-periodic boundary conditions, the solver also needs to be created with non-periodic operators, see, e.g. examples/bbm_bbm_1d/bbm_bbm_1d_basic_reflecting.jl.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"accuracy_order = 4\nsolver = Solver(mesh, accuracy_order)\n\nsemi = Semidiscretization(mesh, equations, initial_condition, solver, boundary_conditions = boundary_conditions)","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"Finally, we put the mesh, the equations, the initial_condition, the solver, and the boundary_conditions together in a semidiscretization semi.","category":"page"},{"location":"basic_example/#Solve-system-of-ordinary-differential-equations","page":"Basic Example","title":"Solve system of ordinary differential equations","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"Once we have obtained a semidiscretization, we can solve the resulting system of ordinary differential equations. To do so, we specify the time interval that we want to simulate and obtain an ODEProblem from the SciML ecosystem for ordinary differential equations by calling semidiscretize on the semidiscretization and the time span.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"Finally, the ode can be solved using the interface from OrdinaryDiffEq.jl. This means we can specify a time-stepping scheme we want to use, the tolerances for the adaptive time-stepping, and the time values, where the solution values should be saved. In this case, we use the adaptive explicit Runge-Kutta method Tsit5 by Tsitouras of order 5(4), which is implemented in the subpackage OrdinaryDiffEqTsit5.jl. If you want to use other time-stepping schemes, you can install the respective subpackage or the whole package OrdinaryDiffEq.jl, which will install every available solver. Here, we save the solution at 100 equidistant points in time.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"tspan = (0.0, 25.0)\node = semidiscretize(semi, tspan)\n\nsaveat = range(tspan..., length = 100)\nsol = solve(ode, Tsit5(), abstol = 1e-7, reltol = 1e-7, saveat = saveat)","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"After solving the equations, sol contains the solution for each of the—in this case—three variables at every spatial point for each of the 100 points in time.","category":"page"},{"location":"basic_example/#visualize_results","page":"Basic Example","title":"Visualize results","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"After running the simulation, the results can be visualized using Plots.jl, which needs to be imported first. Then, we can plot the solution at the final time by calling plot on a Pair of the Semidiscretization and the corresponding ODESolution sol. The result is depicted in the following picture.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"using Plots\n# default( grid=true, box=:on, dpi=100, titlefont=font(16), linewidth=3, gridlinewidth=2, markersize=4, markerstrokewidth=2, xtickfontsize=14, ytickfontsize=14, xguidefontsize=16, yguidefontsize=16, ztickfontsize=14, zguidefontsize=16, legendfontsize=14) # hide\nplot(semi => sol)\nsavefig(\"shoaling_solution.png\") # hide\nnothing # hide","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"(Image: shoaling solution)","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"By default, this will plot the bathymetry, but not the initial (analytical) solution. ","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"You can adjust this by passing the boolean values plot_bathymetry (if true, always plot bathymetry in the first subplot) and plot_initial. Note that plot_initial = true will evaluate and plot the initial condition function at the same time t as the numerical solution being displayed (the final time by default). This means if your initial condition function represents an analytical solution, setting plot_initial = true will plot the analytical solution at that specific time for comparison.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"Plotting an animation over time can, e.g., be done by the following command, which uses step to plot the solution at a specific time step. Here conversion = waterheight_total makes it so that we only look at the waterheight eta and not also the velocity v. More on conversion functions for plotting can be found at TODO!!.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"anim = @animate for step in 1:length(sol.u)\n    plot(semi => sol, plot_initial = true, conversion = waterheight_total, step = step, xlims = (-50, 20), ylims = (-0.8, 0.1))\nend\ngif(anim, \"shoaling_solution.gif\", fps = 25)\nnothing # hide","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"(Image: shoaling solution)","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"It is also possible to plot the solution variables at a fixed spatial point over time by calling plot(semi => sol, x) for some x-value, see the chapter Plotting Simulation Results in this documentation for some examples.","category":"page"},{"location":"basic_example/#More-examples","page":"Basic Example","title":"More examples","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"More examples sorted by the simulated equations can be found in the examples/ subdirectory.","category":"page"},{"location":"basic_example/#overview-plain-program","page":"Basic Example","title":"Plain program","text":"","category":"section"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"Here follows a version of the program without any comments.","category":"page"},{"location":"basic_example/","page":"Basic Example","title":"Basic Example","text":"using DispersiveShallowWater, OrdinaryDiffEqTsit5\n\nequations = BBMBBMEquations1D(bathymetry_type = bathymetry_variable, gravity = 9.81)\n\nfunction initial_condition_shoaling(x, t, equations::BBMBBMEquations1D, mesh)\n    A = 0.07 # amplitude of wave\n    x0 = -30 # initial center\n    eta = A * exp(-0.1*(x - x0)^2)\n    v = 0\n    D = x <= 0.0 ? 0.7 : 0.7 - 1/50 * x\n    return SVector(eta, v, D)\nend\n\ninitial_condition = initial_condition_shoaling\nboundary_conditions = boundary_condition_periodic\n\ncoordinates_min = -130.0\ncoordinates_max = 20.0\nN = 512\nmesh = Mesh1D(coordinates_min, coordinates_max, N)\n\nsolver = Solver(mesh, 4)\n\nsemi = Semidiscretization(mesh, equations, initial_condition, solver, boundary_conditions = boundary_conditions)\n\ntspan = (0.0, 25.0)\node = semidiscretize(semi, tspan)\n\nsaveat = range(tspan..., length = 100)\nsol = solve(ode, Tsit5(), abstol = 1e-7, reltol = 1e-7, saveat = saveat)\n\nusing Plots\nplot(semi => sol)\n\nanim = @animate for step in 1:length(sol.u)\n    plot(semi => sol, plot_initial = true, conversion = waterheight_total, step = step, xlims = (-50, 20), ylims = (-0.8, 0.1))\nend\ngif(anim, \"shoaling_solution.gif\", fps = 25)","category":"page"},{"location":"changelog_tmp/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"DispersiveShallowWater.jl follows the interpretation of semantic versioning (semver) used in the Julia ecosystem. Notable changes will be documented in this file for human readability.","category":"page"},{"location":"changelog_tmp/#Changes-in-the-v0.7-lifecycle","page":"Changelog","title":"Changes in the v0.7 lifecycle","text":"","category":"section"},{"location":"changelog_tmp/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Add linear dispersion relation for the KdVEquation1D (#230).\nSupport reflecting boundary conditions for HyperbolicSerreGreenNaghdiEquations1D (#228).\nAdd conversion functions prim2nondim and nondim2prim for non-dimensional variables for KdVEquation1D (#217).\nSupport reflecting boundary conditions for SerreGreenNaghdiEquations1D (flat bathymetry: #205, general: #223).\nAdd KdVEquation1D (#198).","category":"page"},{"location":"changelog_tmp/#Changes-when-updating-to-v0.7-from-v0.6.x","page":"Changelog","title":"Changes when updating to v0.7 from v0.6.x","text":"","category":"section"},{"location":"changelog_tmp/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"The default parameters of the SvaerdKalischEquations1D changed from alpha = 0.0, beta = 0.2308939393939394, gamma = 0.04034343434343434 to alpha = 0.0, beta = 1/3, gamma = 0.0 (#196).","category":"page"},{"location":"changelog_tmp/#Changes-in-the-v0.6-lifecycle","page":"Changelog","title":"Changes in the v0.6 lifecycle","text":"","category":"section"},{"location":"changelog_tmp/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Support source terms for SerreGreenNaghdiEquations1D (#180, #186).\nAdd initial support for ForwardDiff.jl for HyperbolicSerreGreenNaghdiEquations1D and DispersiveShallowWater.jacobian (#185).","category":"page"},{"location":"changelog_tmp/#Changes-when-updating-to-v0.6-from-v0.5.x","page":"Changelog","title":"Changes when updating to v0.6 from v0.5.x","text":"","category":"section"},{"location":"changelog_tmp/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"The keyword argument and function gravity_constant have been changed to gravity (#174).","category":"page"},{"location":"changelog_tmp/#Changes-in-the-v0.5-lifecycle","page":"Changelog","title":"Changes in the v0.5 lifecycle","text":"","category":"section"},{"location":"changelog_tmp/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Add LinearDispersionRelation and documentation about dispersion (#168).\nReflecting boundary conditions are added for the Svärd-Kalisch equations with alpha = gamma = 0 (#166).\nFix a bug in the upwind discretization of the SvaerdKalischEquations1D.\nUse OrdinaryDiffEqTsit5.jl and OrdinaryDiffEqLowStorageRK.jl instead of OrdinaryDiffEq.jl in all examples to reduce latency (#163).\nAllow Fourier and periodic rational derivative operators for BBMBBMEquations1D and SvaerdKalischEquations1D (#154).\nAdd BBMEquation1D (#150).","category":"page"},{"location":"changelog_tmp/#Changes-when-updating-to-v0.5-from-v0.4.x","page":"Changelog","title":"Changes when updating to v0.5 from v0.4.x","text":"","category":"section"},{"location":"changelog_tmp/#Changed-3","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"The BBMBBMVariableEquations1D were removed and BBMBBMEquations1D now supports a bathymetry_type to choose between a flat and a variable bathymetry (#147).\nThe default of bathymetry_type for the SerreGreenNaghdiEquations1D changed from bathymetry_flat to bathymetry_variable (#147).\nbathymetry_type is now a keyword argument for all equations instead of a positional argument (#147).\nThe initial_condition_dingemans for the SerreGreenNaghdiEquations1D and HyperbolicSerreGreenNaghdiEquations1D was changed a bit to be more consistent with the other equations (#147).","category":"page"},{"location":"changelog_tmp/#Changes-in-the-v0.4-lifecycle","page":"Changelog","title":"Changes in the v0.4 lifecycle","text":"","category":"section"},{"location":"changelog_tmp/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"The SerreGreenNaghdiEquations1D were added for different types of bathymetry (#127, #135).\nThe HyperbolicSerreGreenNaghdiEquations1D were added for different types of bathymetry (#139).\nThe abstract interface AbstractShallowWaterEquations was added to unify several systems such as the SerreGreenNaghdiEquations1D, the BBMBBMEquations1D, and the SvaerdKalischEquations1D (#127).\nA new conversion function prim2phys was introduced, defaulting to prim2prim. prim2phys is the default conversion function for plotting.","category":"page"},{"location":"changelog_tmp/#Changes-when-updating-to-v0.4-from-v0.3.x","page":"Changelog","title":"Changes when updating to v0.4 from v0.3.x","text":"","category":"section"},{"location":"changelog_tmp/#Changed-4","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Use ArrayPartition from RecursiveArrayTools.jl to store the solution of the ODEProblem (#118).","category":"page"},{"location":"changelog_tmp/#Changes-in-the-v0.3-lifecycle","page":"Changelog","title":"Changes in the v0.3 lifecycle","text":"","category":"section"},{"location":"changelog_tmp/#Added-5","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Add possibility to pass vector of Ns to convergence_test (#113).\nPerformance improvements by using factorized matrices for linear systems solves (#108, #112, #114).\nReflecting boundary conditions are added for the BBM-BBM equations (#104, #109).\nFix for the BBMBBMVariableEquations1D, where the still water surface was neglected leading to a bug in the Dingemans setup (#91).","category":"page"},{"location":"changelog_tmp/#Changes-when-updating-to-v0.3-from-v0.2.x","page":"Changelog","title":"Changes when updating to v0.3 from v0.2.x","text":"","category":"section"},{"location":"changelog_tmp/#Changed-5","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Add keyword argument start_from when plotting AnalysisCallback (#87).\nManufactured solution for Svärd-Kalisch equations uses a variable bathymetry (#84).","category":"page"},{"location":"changelog_tmp/#Changes-in-the-v0.2-lifecycle","page":"Changelog","title":"Changes in the v0.2 lifecycle","text":"","category":"section"},{"location":"changelog_tmp/#Added-6","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"Add SummaryCallback (#75).","category":"page"},{"location":"changelog_tmp/#Changes-when-updating-to-v0.2-from-v0.1.x","page":"Changelog","title":"Changes when updating to v0.2 from v0.1.x","text":"","category":"section"},{"location":"changelog_tmp/#Changed-6","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog_tmp/","page":"Changelog","title":"Changelog","text":"The code from the master thesis of Joshua Lampert was separated (#69).\nAdd support for source terms (#65).\nA higher order interpolation is used when plotting the solution at a value x outside the grid (#64).","category":"page"},{"location":"solvers/#solvers","page":"Using different Solvers","title":"Solvers","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"This chapter covers different solvers and how to use them in DispersiveShallowWater.jl.","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"To learn more about the analytical and mathematical background, go to the chapter about Summation by Parts Operators.","category":"page"},{"location":"solvers/#Introduction","page":"Using different Solvers","title":"Introduction","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"DispersiveShallowWater.jl uses SummationByPartsOperators.jl as the foundation for all spatial discretizations. This package provides a comprehensive collection of summation-by-parts (SBP) operators that enable structure-preserving numerical methods with provable stability and conservation properties.","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"The Solver struct in DispersiveShallowWater.jl wraps the SBP operators needed for spatial discretization: typically a first-derivative operator D1, and optionally second- and third-derivative operators D2 and D3, depending on the equation system being solved.","category":"page"},{"location":"solvers/#Design-Philosophy:-Flexibility-and-Modularity","page":"Using different Solvers","title":"Design Philosophy: Flexibility and Modularity","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"DispersiveShallowWater.jl follows a modular design that separates the choice of spatial discretization from the underlying equation systems. This design allows users to:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"Compare discretization methods: Test finite difference, discontinuous Galerkin, continuous Galerkin, and Fourier spectral approaches on identical problems\nInvestigate operator properties: Analyze how different SBP operators preserve conservation laws and stability properties","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"This modularity is particularly relevant for research applications where the choice of discretization can significantly impact the preservation of physical invariants and long-time numerical stability. The unified interface enables systematic studies of numerical method performance without requiring separate implementations for each approach.","category":"page"},{"location":"solvers/#Basic-Summation-by-Parts-Solver","page":"Using different Solvers","title":"Basic Summation by Parts Solver","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"As we have already seen in the basic example, the easiest way to create a solver is to pass both a mesh and the desired accuracy order to the Solver function. This creates first-, second-, and third-derivative periodic summation-by-parts operators of the given accuracy order on the specified mesh:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"accuracy_order = 4\nsolver = Solver(mesh, accuracy_order)","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"This approach creates periodic SBP operators and only works with periodic boundary conditions. If a solver containing periodic SBP operators is passed to Semidiscretization with non-periodic boundary conditions, it will throw an error.","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"note: Accuracy Order Selection\nEven accuracy orders are generally preferred for central difference operators as they provide symmetric stencils. Odd accuracy orders may result in reduced convergence rates due to asymmetric stencils.","category":"page"},{"location":"solvers/#customize_solver","page":"Using different Solvers","title":"Customizing Solvers","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"For more advanced use cases, you can create custom solvers by explicitly constructing the required SBP operators. The general pattern is:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"solver = Solver(D1, D2, D3)","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"where:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"D1 is always required and must be an AbstractDerivativeOperator \nD2 and D3 are optional and can be either AbstractDerivativeOperators, AbstractMatrixes, or nothing","category":"page"},{"location":"solvers/#Reflecting-Boundary-Conditions","page":"Using different Solvers","title":"Reflecting Boundary Conditions","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"For non-periodic boundary conditions, you need to use non-periodic SBP operators. Here's how to create a solver for reflecting boundary conditions:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"using SummationByPartsOperators: MattssonNordström2004, derivative_operator\n\n# Create solver with SBP operators of accuracy order 4\naccuracy_order = 4\nD1 = derivative_operator(MattssonNordström2004(),\n                         derivative_order = 1, accuracy_order = accuracy_order,\n                         xmin = mesh.xmin, xmax = mesh.xmax, N = mesh.N)\nsolver = Solver(D1)","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"The MattssonNordström2004() operator family provides SBP operators that satisfy the SBP property with non-periodic boundary conditions, making them suitable for reflecting boundary conditions.","category":"page"},{"location":"solvers/#Upwind-Operators","page":"Using different Solvers","title":"Upwind Operators","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"For equations that benefit from upwind discretizations (such as the Serre-Green-Naghdi equations), you can use upwind SBP Operators:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"For periodic boundary conditions:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"using SummationByPartsOperators: upwind_operators, periodic_derivative_operator\n\naccuracy_order = 4\nD1 = upwind_operators(periodic_derivative_operator;\n                      derivative_order = 1,\n                      accuracy_order = accuracy_order,\n                      xmin = xmin(mesh), xmax = xmax(mesh),\n                      N = nnodes(mesh))\nsolver = Solver(D1)","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"For reflecting boundary conditions:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"using SummationByPartsOperators: Mattsson2017, upwind_operators\n\naccuracy_order = 2\nD1 = upwind_operators(Mattsson2017, derivative_order = 1, accuracy_order = accuracy_order,\n                      xmin = xmin(mesh), xmax = xmax(mesh),\n                      N = nnodes(mesh))\nsolver = Solver(D1)","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"Upwind operators provide additional dissipation and often achieve higher resolution for sharp features compared to central operators.","category":"page"},{"location":"solvers/#KdV-Equations-with-Third-Derivative-Operators","page":"Using different Solvers","title":"KdV Equations with Third-Derivative Operators","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"The KdV equation requires first- and third-derivative operators, but no second-derivative operator. You can specify this by passing nothing for the second argument:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"using SummationByPartsOperators: fourier_derivative_operator\n\n# Create solver with Fourier SBP operators\nD1 = fourier_derivative_operator(xmin(mesh), xmax(mesh), nnodes(mesh))\nD3 = D1^3  # Third derivative via composition\n\nsolver = Solver(D1, nothing, D3)","category":"page"},{"location":"solvers/#Using-Sparse-Matrices-for-Derivative-Operators","page":"Using different Solvers","title":"Using Sparse Matrices for Derivative Operators","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"While D1 must always be an SBP operator, D2 and D3 can be regular sparse matrices. This can be useful for creating custom discretizations:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"using SummationByPartsOperators: upwind_operators, periodic_derivative_operator\nusing SparseArrays: sparse\n\naccuracy_order = 4\nD1 = upwind_operators(periodic_derivative_operator; derivative_order = 1,\n                      accuracy_order = accuracy_order, xmin = mesh.xmin, xmax = mesh.xmax,\n                      N = mesh.N)\nD2 = sparse(D1.plus) * sparse(D1.minus)  # Create D2 as sparse matrix\nsolver = Solver(D1, D2)","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"warning: Performance consideration\nWhile using sparse matrices for D2 and D3 provides flexibility, SBP operator-vector products are typically about an order of magnitude faster than sparse matrix-vector products. See the SummationByPartsOperators.jl benchmarks for details.","category":"page"},{"location":"solvers/#Discontinuous-Galerkin-Methods","page":"Using different Solvers","title":"Discontinuous Galerkin Methods","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"DispersiveShallowWater.jl supports discontinuous Galerkin (DG) methods through coupled Legendre operators:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"using SummationByPartsOperators: legendre_derivative_operator,\n                                 UniformPeriodicMesh1D,\n                                 couple_discontinuously\nusing SparseArrays: sparse\n\n# Create solver with DG operators\np = 3  # polynomial degree (N needs to be divisible by p + 1)\nD_legendre = legendre_derivative_operator(-1.0, 1.0, p + 1)\nuniform_mesh = UniformPeriodicMesh1D(coordinates_min, coordinates_max, div(N, p + 1))\n\nD1 = couple_discontinuously(D_legendre, uniform_mesh)\nD_pl = couple_discontinuously(D_legendre, uniform_mesh, Val(:plus))\nD_min = couple_discontinuously(D_legendre, uniform_mesh, Val(:minus))\nD2 = sparse(D_pl) * sparse(D_min)\n\nsolver = Solver(D1, D2)","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"This approach creates a DG discretization with polynomial degree p within each element.","category":"page"},{"location":"solvers/#Fourier-Spectral-Methods","page":"Using different Solvers","title":"Fourier Spectral Methods","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"Fourier collocation methods can be interpreted as periodic SBP operators, which can be constructed via fourier_derivative_operator:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"using SummationByPartsOperators: fourier_derivative_operator\n\n# Create solver with Fourier pseudospectral collocation method\nD1 = fourier_derivative_operator(xmin(mesh), xmax(mesh), nnodes(mesh))\nsolver = Solver(D1)","category":"page"},{"location":"solvers/#Variable-Coefficient-Operators","page":"Using different Solvers","title":"Variable Coefficient Operators","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"Variable coefficient operators can be useful when solving PDEs that involve elliptic systems with variable coefficients. Using them can lead to fewer allocations.","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"using SummationByPartsOperators: Mattsson2012, derivative_operator,\n                                 var_coef_derivative_operator\n\naccuracy_order = 2\nD1 = derivative_operator(Mattsson2012();\n                         derivative_order = 1, accuracy_order,\n                         xmin = xmin(mesh), xmax = xmax(mesh), N = N)\n# Create a variable-coefficient second-derivative operator\n# Initialize with coefficient function `one` - coefficients will be set during simulation\nD2 = var_coef_derivative_operator(Mattsson2012(),\n                                  2, accuracy_order,\n                                  xmin(mesh), xmax(mesh), N, one)\nsolver = Solver(D1, D2)","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"warning: Limited compatibility\nVariable coefficient operators (VarCoefDerivativeOperator) are currently only supported for the Serre-Green-Naghdi equations with reflecting boundary conditions and flat bathymetry. This is a specialized feature for specific use cases.","category":"page"},{"location":"solvers/#Using-Your-Custom-Solver","page":"Using different Solvers","title":"Using Your Custom Solver","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"Once you have created your solver object using any of the approaches above, you can use it in a Semidiscretization:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"semi = Semidiscretization(mesh, equations, initial_condition, solver,\n                          boundary_conditions = boundary_conditions)","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"The solver you choose should be compatible with your boundary conditions:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"Periodic operators (created with periodic_derivative_operator or fourier_derivative_operator) require boundary_condition_periodic\nNon-periodic operators (created with MattssonNordström2004, etc.) are needed for boundary_condition_reflecting","category":"page"},{"location":"solvers/#Common-Pitfalls","page":"Using different Solvers","title":"Common Pitfalls","text":"","category":"section"},{"location":"solvers/#Mismatched-Operators-and-Boundary-Conditions","page":"Using different Solvers","title":"Mismatched Operators and Boundary Conditions","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"Problem: Using periodic operators with reflecting boundary conditions or vice versa.","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"# ❌ This will fail\nD1 = periodic_derivative_operator(1, 4, mesh.xmin, mesh.xmax, mesh.N)\nsolver = Solver(D1)\nsemi = Semidiscretization(mesh, equations, initial_condition, solver,\n                          boundary_conditions = boundary_condition_reflecting)  # Error!","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"Solution: Match operator type to boundary conditions:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"# ✅ Correct approach\nD1 = derivative_operator(MattssonNordström2004(), derivative_order = 1, \n                         accuracy_order = 4, xmin = mesh.xmin, xmax = mesh.xmax, N = mesh.N)\nsolver = Solver(D1)\nsemi = Semidiscretization(mesh, equations, initial_condition, solver,\n                          boundary_conditions = boundary_condition_reflecting)","category":"page"},{"location":"solvers/#Incorrect-Grid-Size-for-DG-Methods","page":"Using different Solvers","title":"Incorrect Grid Size for DG Methods","text":"","category":"section"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"Problem: Grid size not divisible by polynomial degree + 1 for DG methods.","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"# ❌ N = 101, p = 3, but 101 is not divisible by (3+1) = 4\nN = 101\np = 3\nmesh = Mesh1D(coordinates_min, coordinates_max, N)  # Error in DG setup!","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"Solution: Ensure N is divisible by p + 1:","category":"page"},{"location":"solvers/","page":"Using different Solvers","title":"Using different Solvers","text":"# ✅ Adjust N to be divisible by p + 1\np = 3\nN = 100  # 100 ÷ 4 = 25 elements exactly\n# Or N = 96, 104, etc. - any multiple of 4","category":"page"},{"location":"SBP_Operators/#sbp_operates","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"","category":"section"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"This chapter covers the analytical and mathematical background of summation-by-parts operators in general.","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"To learn more about different solvers and how to use them in DispersiveShallowWater.jl, go to the chapter about Solvers.","category":"page"},{"location":"SBP_Operators/#1.-Introduction-and-Overview","page":"Summation-by-Parts Operators","title":"1. Introduction & Overview","text":"","category":"section"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"In recent years, summation-by-parts (SBP) operators have gained particular interest in computational mathematics as they allow transferring analytical results from the continuous level to numerical methods in a systematic manner. This is achieved by mimicking integration by parts discretely, which is one of the key ingredients for conservation and stability proofs at the continuous level. In this way, many fundamental analytical properties of hyperbolic-dominated partial differential equations can be obtained in a straightforward manner at the discrete level.[LampertRanocha2024]","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"SBP operators were first developed for finite difference methods to mimic stability proofs based on integration by parts as traditionally used in finite element methods. However, exact integration can be impossible or computationally expensive in finite element methods, particularly for complex geometries or nonlinear problems. In this case, SBP formulations can be advantageous since they naturally include a quadrature rule through the mass matrix. In particular, split forms can be used with SBP operators to avoid the need for exact integration while maintaining discrete analogs of important analytical properties such as the chain rule and product rule.","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"Several classes of numerical methods can be formulated via SBP operators, including finite difference methods, finite volume methods, continuous Galerkin methods, discontinuous Galerkin (DG) methods, and flux reconstruction methods. This unifying framework has made SBP operators a cornerstone of structure-preserving numerical methods across various computational disciplines.","category":"page"},{"location":"SBP_Operators/#Why-SBP-Operators-Matter-for-Dispersive-Shallow-Water-Equations","page":"Summation-by-Parts Operators","title":"Why SBP Operators Matter for Dispersive Shallow Water Equations","text":"","category":"section"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"For dispersive shallow water equations implemented in DispersiveShallowWater.jl, maintaining physical properties like mass and energy conservation is crucial for:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"Long-time stability: Simulations remain stable over extended time periods without spurious growth of numerical errors\nPhysical accuracy: The discrete solution respects fundamental physical laws such as conservation of mass, momentum, and energy\nRobustness: Methods are less sensitive to parameter choices and grid resolution, leading to more reliable simulations","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"SBP operators achieve this by providing:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"Exact conservation: Discrete conservation laws that hold to machine precision\nProvable stability: Mathematical guarantees about the behavior of the numerical method through discrete energy estimates\nFlexibility: A unified framework that encompasses finite differences, finite elements, and spectral methods","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"[LampertRanocha2024]: Lampert, Ranocha (2024): Structure-Preserving Numerical Methods for Two Nonlinear Systems of Dispersive Wave Equations arXiv: 2402.16669","category":"page"},{"location":"SBP_Operators/#2.-Mathematical-Foundation","page":"Summation-by-Parts Operators","title":"2. Mathematical Foundation","text":"","category":"section"},{"location":"SBP_Operators/#The-Core-SBP-Property","page":"Summation-by-Parts Operators","title":"The Core SBP Property","text":"","category":"section"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"The fundamental property that defines a first-derivative SBP operator is:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"MD + D^T M = t_R t_R^T - t_L t_L^T","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"where:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"D is the derivative operator (matrix)\nM is the symmetric, positive definite mass matrix\nboldsymbole_L = (100)^T and boldsymbole_R = (001)^T extract boundary values","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"This property is the discrete analog of integration by parts:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"beginaligned\nunderbrace boldsymbolu^T M D boldsymbolv + boldsymbolu^T D^T M boldsymbolv _displaystyle approx int_x_min^x_max u (partial_x v)textrmdx + int_x_min^x_max (partial_x u) vtextrmdx  \n= \nunderbrace boldsymbolu^T boldsymbolt_R boldsymbolt_R^T boldsymbolv - boldsymbolu^T boldsymbolt_L boldsymbolt_L^T boldsymbolv _displaystyle = u(x_max)v(x_max) - u(x_min)v(x_min) \nendaligned","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"where for periodic SBP operators their property naturally simplifies to","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"MD + D^T M = 0","category":"page"},{"location":"SBP_Operators/#Understanding-the-Mass-Matrix","page":"Summation-by-Parts Operators","title":"Understanding the Mass Matrix","text":"","category":"section"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"The mass matrix M approximates the continuous inner product:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"langle boldsymbolu boldsymbolv rangle_M = boldsymbolu^T M boldsymbolv approx int_x_min^x_max u(x) v(x) dx","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"For the approximation to be meaningful, we require:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"boldsymbol1^T M boldsymbol1 = x_max - x_min","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"This ensures that the discrete inner product correctly integrates constants.","category":"page"},{"location":"SBP_Operators/#Understanding-the-Derivative-Operator","page":"Summation-by-Parts Operators","title":"Understanding the Derivative Operator","text":"","category":"section"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"The derivative operator D approximates the spatial derivative of a function on a discrete grid. That is, for a smooth function u(x), we want the discrete expression D boldsymbolu to approximate partial_x u(x) at the grid points.","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"A first-derivative SBP operator is said to be p-th order accurate if it satisfies:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"D boldsymbolx^k = k boldsymbolx^k-1 quad textfor all  k = 0 1  p","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"where boldsymbolx^k = (x_1^k dots x_N^k)^T. This means the discrete operator correctly differentiates monomials up to degree p. In particular, consistency requires at least zeroth-order accuracy, i.e.,","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"D boldsymbol1 = boldsymbol0","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"However, approximating derivatives near boundaries poses a challenge: interior points can use standard finite difference stencils, but near the edges (e.g., at x_1 or x_N), one must use specially designed one-sided approximations that still preserve stability and accuracy. Periodic SBP Operators do not have this problem.","category":"page"},{"location":"SBP_Operators/#Example:-Central-Difference-Operator","page":"Summation-by-Parts Operators","title":"Example: Central Difference Operator","text":"","category":"section"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"A simple example is the classical second-order central difference operator on a uniform grid:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"D = frac1Delta x beginpmatrix\n-1  1    \n-12  0  12   \n -12  0  12  \n  ddots  ddots  ddots \n   -1  1\nendpmatrix","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"with mass matrix:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"M = Delta x cdot textdiag(12 1 1 ldots 1 12)","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"You can verify that this satisfies the SBP property and provides second-order accuracy in the interior with first-order accuracy at the boundaries.","category":"page"},{"location":"SBP_Operators/#3.-Types-of-SBP-Operators","page":"Summation-by-Parts Operators","title":"3. Types of SBP Operators","text":"","category":"section"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"In practice SBP operators come in various flavours. ","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"upwind vs. central vs. FD vs. DG vs. CG vs. Fourier","category":"page"},{"location":"SBP_Operators/#Central-vs.-Upwind-SBP-Operators","page":"Summation-by-Parts Operators","title":"Central vs. Upwind SBP Operators","text":"","category":"section"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"The choice between central and upwind SBP operators is crucial and depends on the nature of your problem.","category":"page"},{"location":"SBP_Operators/#Central-SBP-Operators","page":"Summation-by-Parts Operators","title":"Central SBP Operators","text":"","category":"section"},{"location":"SBP_Operators/#upwind_sbp","page":"Summation-by-Parts Operators","title":"Upwind SBP Operators","text":"","category":"section"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"Upwind operators come in pairs D_+ and D_- with additional dissipation:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"Key Property: M(D_+ - D_-) is negative semidefinite (provides controlled dissipation)\nMajor Advantage: Higher resolution - better at resolving sharp features\nConstruction: D = (D_+ + D_-)2 gives a central operator","category":"page"},{"location":"SBP_Operators/#Why-Upwind-Operators-Have-Higher-Resolution","page":"Summation-by-Parts Operators","title":"Why Upwind Operators Have Higher Resolution","text":"","category":"section"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"The resolution advantage comes from the stencil structure. Consider discretizing a second derivative:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"Central approach:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"(D^2 u)_i approx fracu_i+2 - 2u_i + u_i-24Delta x^2 quad textWide stencil","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"This wide stencil has grid oscillations of the form (-1+1-1+1ldots) in its null space.","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"Upwind approach:","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"(D^2 u)_i approx fracu_i+1 - 2u_i + u_i-1Delta x^2 quad textNarrow stencil","category":"page"},{"location":"SBP_Operators/","page":"Summation-by-Parts Operators","title":"Summation-by-Parts Operators","text":"The narrow stencil naturally damps high-frequency oscillations, leading to better resolution.","category":"page"},{"location":"SBP_Operators/#Different-SBP-Implementations","page":"Summation-by-Parts Operators","title":"Different SBP Implementations","text":"","category":"section"},{"location":"SBP_Operators/#Finite-Difference-(FD)-SBP","page":"Summation-by-Parts Operators","title":"Finite Difference (FD) SBP","text":"","category":"section"},{"location":"SBP_Operators/#dg_sbp","page":"Summation-by-Parts Operators","title":"Discontinuous Galerkin (DG) SBP","text":"","category":"section"},{"location":"SBP_Operators/#Continuous-Galerkin-(CG)-SBP","page":"Summation-by-Parts Operators","title":"Continuous Galerkin (CG) SBP","text":"","category":"section"},{"location":"SBP_Operators/#fourier_sbp","page":"Summation-by-Parts Operators","title":"Fourier/Spectral SBP","text":"","category":"section"},{"location":"ref-trixibase/#TrixiBase.jl-API","page":"TrixiBase","title":"TrixiBase.jl API","text":"","category":"section"},{"location":"ref-trixibase/#TrixiBase.disable_debug_timings-Tuple{}","page":"TrixiBase","title":"TrixiBase.disable_debug_timings","text":"disable_debug_timings()\n\nDisable all @trixi_timeit timings. The timings should be optimized away, allowing for truly zero-overhead. Enable timings again with enable_debug_timings.\n\nSee also enable_debug_timings, @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.enable_debug_timings-Tuple{}","page":"TrixiBase","title":"TrixiBase.enable_debug_timings","text":"enable_debug_timings()\n\nEnable all @trixi_timeit timings (default behavior).\n\nSee also disable_debug_timings, @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.timer-Tuple{}","page":"TrixiBase","title":"TrixiBase.timer","text":"timer()\n\nMain timer for global timing, e.g., to be used with @trixi_timeit.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.trixi_include-Tuple{Function, Module, AbstractString}","page":"TrixiBase","title":"TrixiBase.trixi_include","text":"trixi_include([mapexpr::Function=identity,] [mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the file elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments. Its basic purpose is to make it easier to modify some parameters while running simulations from the REPL. Additionally, this is used in tests to reduce the computational burden for CI while still providing examples with sensible default values for users.\n\nBefore replacing assignments in elixir, the keyword argument maxiters is inserted into calls to solve with it's default value used in the SciML ecosystem for ODEs, see the \"Miscellaneous\" section of the documentation.\n\nThe optional first argument mapexpr can be used to transform the included code before it is evaluated: for each parsed expression expr in elixir, the include function actually evaluates mapexpr(expr). If it is omitted, mapexpr defaults to identity.\n\nExamples\n\njulia> using TrixiBase, Trixi\n\njulia> redirect_stdout(devnull) do\n         trixi_include(@__MODULE__, joinpath(examples_dir(), \"tree_1d_dgsem\", \"elixir_advection_extended.jl\"),\n                       tspan=(0.0, 0.1))\n         sol.t[end]\n       end\n[ Info: You just called `trixi_include`. Julia may now compile the code, please be patient.\n0.1\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.trixi_include_changeprecision-Tuple{Any, Module, AbstractString}","page":"TrixiBase","title":"TrixiBase.trixi_include_changeprecision","text":"trixi_include_changeprecision(T, [mod::Module=Main,] elixir::AbstractString; kwargs...)\n\ninclude the elixir elixir and evaluate its content in the global scope of module mod. You can override specific assignments in elixir by supplying keyword arguments, similar to trixi_include.\n\nThe only difference to trixi_include is that the precision of floating-point numbers in the included elixir is changed to T. More precisely, the package ChangePrecision.jl is used to convert all Float64 literals, operations like / that produce Float64 results, and functions like ones that return Float64 arrays by default, to the desired type T. See the documentation of ChangePrecision.jl for more details.\n\nThe purpose of this function is to conveniently run a full simulation with Float32, which is orders of magnitude faster on most GPUs than Float64, by just including the elixir with trixi_include_changeprecision(Float32, elixir). Many constructors in the Trixi.jl framework are written in a way that changing all floating-point arguments to Float32 will change the element type to Float32 as well. In TrixiParticles.jl, including an elixir with this macro should be sufficient to run the full simulation with single precision.\n\n\n\n\n\n","category":"method"},{"location":"ref-trixibase/#TrixiBase.@trixi_timeit-Tuple{Any, Any, Any}","page":"TrixiBase","title":"TrixiBase.@trixi_timeit","text":"@trixi_timeit timer() \"some label\" expression\n\nBasically the same as a special case of @timeit_debug from TimerOutputs.jl, but without try ... finally ... end block. Thus, it's not exception-safe, but it also avoids some related performance problems. Since we do not use exception handling in Trixi.jl, that's not really an issue.\n\nAll @trixi_timeit timings can be disabled with disable_debug_timings. The timings should then be optimized away, allowing for truly zero-overhead.\n\nSee also disable_debug_timings, enable_debug_timings.\n\n\n\n\n\n","category":"macro"},{"location":"code_of_conduct/#code-of-conduct","page":"Code of Conduct","title":"Code of Conduct","text":"","category":"section"},{"location":"code_of_conduct/","page":"Code of Conduct","title":"Code of Conduct","text":"Contributor Covenant Code of ConductOur PledgeWe as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.Our StandardsExamples of behavior that contributes to a positive environment for our community include:Demonstrating empathy and kindness toward other people\nBeing respectful of differing opinions, viewpoints, and experiences\nGiving and gracefully accepting constructive feedback\nAccepting responsibility and apologizing to those affected by our mistakes, and learning from the experience\nFocusing on what is best not just for us as individuals, but for the overall communityExamples of unacceptable behavior include:The use of sexualized language or imagery, and sexual attention or advances of any kind\nTrolling, insulting or derogatory comments, and personal or political attacks\nPublic or private harassment\nPublishing others' private information, such as a physical or email address, without their explicit permission\nOther conduct which could reasonably be considered inappropriate in a professional settingEnforcement ResponsibilitiesCommunity leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.ScopeThis Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event.EnforcementInstances of abusive, harassing, or otherwise unacceptable behavior may be reported to Joshua Lampert or Hendrik Ranocha. All complaints will be reviewed and investigated promptly and fairly.All community leaders are obligated to respect the privacy and security of the reporter of any incident.Enforcement GuidelinesCommunity leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:1. CorrectionCommunity Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.2. WarningCommunity Impact: A violation through a single incident or series of actions.Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.3. Temporary BanCommunity Impact: A serious violation of community standards, including sustained inappropriate behavior.Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.4. Permanent BanCommunity Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior,  harassment of an individual, or aggression toward or disparagement of classes of individuals.Consequence: A permanent ban from any sort of public interaction within the community.AttributionThis Code of Conduct is adapted from the [Contributor Covenant][homepage], version 2.0.Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.[homepage]: https://www.contributor-covenant.orgFor answers to common questions about this code of conduct, see the  FAQ.  Translations  are also available there.","category":"page"},{"location":"changelog/#Changelog","page":"Changelog","title":"Changelog","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"DispersiveShallowWater.jl follows the interpretation of semantic versioning (semver) used in the Julia ecosystem. Notable changes will be documented in this file for human readability.","category":"page"},{"location":"changelog/#Changes-in-the-v0.7-lifecycle","page":"Changelog","title":"Changes in the v0.7 lifecycle","text":"","category":"section"},{"location":"changelog/#Added","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Add linear dispersion relation for the KdVEquation1D (#230).\nSupport reflecting boundary conditions for HyperbolicSerreGreenNaghdiEquations1D (#228).\nAdd conversion functions prim2nondim and nondim2prim for non-dimensional variables for KdVEquation1D (#217).\nSupport reflecting boundary conditions for SerreGreenNaghdiEquations1D (flat bathymetry: #205, general: #223).\nAdd KdVEquation1D (#198).","category":"page"},{"location":"changelog/#Changes-when-updating-to-v0.7-from-v0.6.x","page":"Changelog","title":"Changes when updating to v0.7 from v0.6.x","text":"","category":"section"},{"location":"changelog/#Changed","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The default parameters of the SvaerdKalischEquations1D changed from alpha = 0.0, beta = 0.2308939393939394, gamma = 0.04034343434343434 to alpha = 0.0, beta = 1/3, gamma = 0.0 (#196).","category":"page"},{"location":"changelog/#Changes-in-the-v0.6-lifecycle","page":"Changelog","title":"Changes in the v0.6 lifecycle","text":"","category":"section"},{"location":"changelog/#Added-2","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Support source terms for SerreGreenNaghdiEquations1D (#180, #186).\nAdd initial support for ForwardDiff.jl for HyperbolicSerreGreenNaghdiEquations1D and DispersiveShallowWater.jacobian (#185).","category":"page"},{"location":"changelog/#Changes-when-updating-to-v0.6-from-v0.5.x","page":"Changelog","title":"Changes when updating to v0.6 from v0.5.x","text":"","category":"section"},{"location":"changelog/#Changed-2","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The keyword argument and function gravity_constant have been changed to gravity (#174).","category":"page"},{"location":"changelog/#Changes-in-the-v0.5-lifecycle","page":"Changelog","title":"Changes in the v0.5 lifecycle","text":"","category":"section"},{"location":"changelog/#Added-3","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Add LinearDispersionRelation and documentation about dispersion (#168).\nReflecting boundary conditions are added for the Svärd-Kalisch equations with alpha = gamma = 0 (#166).\nFix a bug in the upwind discretization of the SvaerdKalischEquations1D.\nUse OrdinaryDiffEqTsit5.jl and OrdinaryDiffEqLowStorageRK.jl instead of OrdinaryDiffEq.jl in all examples to reduce latency (#163).\nAllow Fourier and periodic rational derivative operators for BBMBBMEquations1D and SvaerdKalischEquations1D (#154).\nAdd BBMEquation1D (#150).","category":"page"},{"location":"changelog/#Changes-when-updating-to-v0.5-from-v0.4.x","page":"Changelog","title":"Changes when updating to v0.5 from v0.4.x","text":"","category":"section"},{"location":"changelog/#Changed-3","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The BBMBBMVariableEquations1D were removed and BBMBBMEquations1D now supports a bathymetry_type to choose between a flat and a variable bathymetry (#147).\nThe default of bathymetry_type for the SerreGreenNaghdiEquations1D changed from bathymetry_flat to bathymetry_variable (#147).\nbathymetry_type is now a keyword argument for all equations instead of a positional argument (#147).\nThe initial_condition_dingemans for the SerreGreenNaghdiEquations1D and HyperbolicSerreGreenNaghdiEquations1D was changed a bit to be more consistent with the other equations (#147).","category":"page"},{"location":"changelog/#Changes-in-the-v0.4-lifecycle","page":"Changelog","title":"Changes in the v0.4 lifecycle","text":"","category":"section"},{"location":"changelog/#Added-4","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The SerreGreenNaghdiEquations1D were added for different types of bathymetry (#127, #135).\nThe HyperbolicSerreGreenNaghdiEquations1D were added for different types of bathymetry (#139).\nThe abstract interface AbstractShallowWaterEquations was added to unify several systems such as the SerreGreenNaghdiEquations1D, the BBMBBMEquations1D, and the SvaerdKalischEquations1D (#127).\nA new conversion function prim2phys was introduced, defaulting to prim2prim. prim2phys is the default conversion function for plotting.","category":"page"},{"location":"changelog/#Changes-when-updating-to-v0.4-from-v0.3.x","page":"Changelog","title":"Changes when updating to v0.4 from v0.3.x","text":"","category":"section"},{"location":"changelog/#Changed-4","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Use ArrayPartition from RecursiveArrayTools.jl to store the solution of the ODEProblem (#118).","category":"page"},{"location":"changelog/#Changes-in-the-v0.3-lifecycle","page":"Changelog","title":"Changes in the v0.3 lifecycle","text":"","category":"section"},{"location":"changelog/#Added-5","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Add possibility to pass vector of Ns to convergence_test (#113).\nPerformance improvements by using factorized matrices for linear systems solves (#108, #112, #114).\nReflecting boundary conditions are added for the BBM-BBM equations (#104, #109).\nFix for the BBMBBMVariableEquations1D, where the still water surface was neglected leading to a bug in the Dingemans setup (#91).","category":"page"},{"location":"changelog/#Changes-when-updating-to-v0.3-from-v0.2.x","page":"Changelog","title":"Changes when updating to v0.3 from v0.2.x","text":"","category":"section"},{"location":"changelog/#Changed-5","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Add keyword argument start_from when plotting AnalysisCallback (#87).\nManufactured solution for Svärd-Kalisch equations uses a variable bathymetry (#84).","category":"page"},{"location":"changelog/#Changes-in-the-v0.2-lifecycle","page":"Changelog","title":"Changes in the v0.2 lifecycle","text":"","category":"section"},{"location":"changelog/#Added-6","page":"Changelog","title":"Added","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"Add SummaryCallback (#75).","category":"page"},{"location":"changelog/#Changes-when-updating-to-v0.2-from-v0.1.x","page":"Changelog","title":"Changes when updating to v0.2 from v0.1.x","text":"","category":"section"},{"location":"changelog/#Changed-6","page":"Changelog","title":"Changed","text":"","category":"section"},{"location":"changelog/","page":"Changelog","title":"Changelog","text":"The code from the master thesis of Joshua Lampert was separated (#69).\nAdd support for source terms (#65).\nA higher order interpolation is used when plotting the solution at a value x outside the grid (#64).","category":"page"},{"location":"license/#License","page":"License","title":"License","text":"","category":"section"},{"location":"license/","page":"License","title":"License","text":"MIT License","category":"page"},{"location":"license/","page":"License","title":"License","text":"Copyright (c) 2023-present Joshua Lampert <joshua.lampert@uni-hamburg.de> and contributors","category":"page"},{"location":"license/","page":"License","title":"License","text":"Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:","category":"page"},{"location":"license/","page":"License","title":"License","text":"The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.","category":"page"},{"location":"license/","page":"License","title":"License","text":"THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.","category":"page"},{"location":"miscellaneous/#Miscellaneous","page":"Miscellaneous","title":"Miscellaneous","text":"","category":"section"},{"location":"miscellaneous/","page":"Miscellaneous","title":"Miscellaneous","text":"lets see what comes","category":"page"},{"location":"overview/#equations","page":"Overview","title":"Equations","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"DispersiveShallowWater.jl provides six different dispersive shallow water equation systems for modeling water waves. Each equation system offers different levels of physical accuracy, computational complexity, and supports various boundary conditions and bathymetry types.","category":"page"},{"location":"overview/#eq_overview","page":"Overview","title":"Supported Models and Features","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"The following table provides an overview of all available equation systems and their supported features:","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"Equation Variables Periodic boundary conditions Reflecting boundary conditions Flat Bathymetry Mild-slope Bathymetry Variable Bathymetry Relaxation Source Terms\nKdV (eta) ✅ ❌ ✅ ❌ ❌ ✅ ✅\nBBM (eta) ✅ ❌ ✅ ❌ ❌ ✅ ✅\nBBM-BBM (eta v D) ✅ ✅ ✅ ❌ ✅ ✅ ✅\nSvärd-Kalisch (eta v D) ✅ ✅ᵃ ❌ ❌ ✅ ✅ ✅\nSerre-Green-Naghdi (eta v D) ✅ ✅ ✅ ✅ ✅ ✅ ✅\nHyperbolic SGN (eta v D w H) ✅ ✅ ✅ ✅ ❌ ✅ ✅","category":"page"},{"location":"overview/","page":"Overview","title":"Overview","text":"ᵃReflecting boundary conditions for Svärd-Kalisch equations require alpha = gamma = 0","category":"page"},{"location":"overview/#Variable-Descriptions","page":"Overview","title":"Variable Descriptions","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"eta: Total water height\nv: Velocity in horizontal direction  \nD: Still-water depth\nw: Auxiliary variable in hyperbolic approximation (approx -h v_x)\nH: Auxiliary variable in hyperbolic approximation (approx h)","category":"page"},{"location":"overview/#Detailed-Documentation","page":"Overview","title":"Detailed Documentation","text":"","category":"section"},{"location":"overview/","page":"Overview","title":"Overview","text":"Each equation system below includes its complete mathematical formulation, physical background, implementation details, conservation properties, and relevant literature references.","category":"page"},{"location":"overview/#Benjamin-Bona-Mahony-(BBM)","page":"Overview","title":"Benjamin-Bona-Mahony (BBM)","text":"","category":"section"},{"location":"overview/#DispersiveShallowWater.BBMEquation1D","page":"Overview","title":"DispersiveShallowWater.BBMEquation1D","text":"BBMEquation1D(; gravity, D = 1.0, eta0 = 0.0, split_form = true)\n\nBBM (Benjamin–Bona–Mahony) equation in one spatial dimension. The equation is given by\n\nbeginaligned\n  eta_t + sqrtgDeta_x + frac32sqrtfracgDetaeta_x - frac16D^2eta_xxt = 0\nendaligned\n\nThe unknown quantity of the BBM equation is the total water height eta. The gravitational acceleration gravity is denoted by g and the constant bottom topography (bathymetry) b = eta_0 - D, where eta_0 is the constant still-water surface and D the still-water depth. The water height above the bathymetry is therefore given by h = eta - eta_0 + D. The BBM equation is only implemented for eta_0 = 0.\n\nThe equations only support a flat bathymetry.\n\nThe BBM equation is first described in Benjamin, Bona, and Mahony (1972). The semidiscretization implemented here is developed in Ranocha, Mitsotakis, and Ketcheson (2020) for split_form = true and in Linders, Ranocha, and Birken (2023) for split_form = false. If split_form is true, a split form in the semidiscretization is used, which conserves\n\nthe total water mass (integral of h) as a linear invariant\na quadratic invariant (integral of 12eta(eta - 16D^2eta_xx) or for periodic boundary conditions equivalently 12(eta^2 + 16D^2eta_x^2)), which is called here energy_total_modified (and entropy_modified) because it contains derivatives of the solution\n\nfor periodic boundary conditions. If split_form is false the semidiscretization conserves\n\nthe total water mass (integral of h) as a linear invariant\nthe Hamiltonian (integral of 14sqrtgDeta^3 + 12sqrtgDeta^2) (see hamiltonian)\n\nfor periodic boundary conditions.\n\nThomas B. Benjamin, Jerry L. Bona and John J. Mahony (1972) Model equations for long waves in nonlinear dispersive systems DOI: 10.1098/rsta.1972.0032\nHendrik Ranocha, Dimitrios Mitsotakis and David I. Ketcheson (2020) A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations DOI: 10.4208/cicp.OA-2020-0119\nViktor Linders, Hendrik Ranocha and Philipp Birken (2023) Resolving entropy growth from iterative methods DOI: 10.1007/s10543-023-00992-w\n\n\n\n\n\n","category":"type"},{"location":"overview/#Korteweg–De-Vries-(KdV)","page":"Overview","title":"Korteweg–De Vries (KdV)","text":"","category":"section"},{"location":"overview/#DispersiveShallowWater.KdVEquation1D","page":"Overview","title":"DispersiveShallowWater.KdVEquation1D","text":"KdVEquation1D(; gravity, D = 1.0, eta0 = 0.0)\n\nKdV (Korteweg-de Vries) equation in one spatial dimension. The equation is given by\n\nbeginaligned\n  eta_t+sqrtg D eta_x+3  2 sqrtg  D eta eta_x+1  6 sqrtg D D^2 eta_x x x = 0\nendaligned\n\nThe unknown quantity of the KdV equation is the total water height eta. The gravitational acceleration gravity is denoted by g and the constant bottom topography (bathymetry) b = eta_0 - D, where eta_0 is the constant still-water surface and D the still-water depth. The water height above the bathymetry is therefore given by h = eta - eta_0 + D. The KdV equation is only implemented for eta_0 = 0.\n\nThe equations only support a flat bathymetry.\n\nThe KdV equation is first introduced by Joseph Valentin Boussinesq (1877) and rediscovered by Diederik Korteweg and Gustav de Vries in 1895.\n\nThe semidiscretization implemented here is a modification of the one proposed by Biswas, Ketcheson, Ranocha, and Schütz (2025) for the non-dimensionalized KdV equation u_t + u u_x + u_x x x = 0\n\nThe semidiscretization looks the following:\n\nbeginaligned\n  eta_t+sqrtg D D_1eta+ 1  2 sqrtg  D eta D_1 eta +  1  2 sqrtg  D D_1 eta^2 +1  6 sqrtg D D^2 D_3eta = 0\nendaligned\n\nwhere D_1 is a first-derivative operator, D_3 a third-derivative operator, and D the still-water depth.\n\nIt conserves\n\nthe total water mass (integral of eta) as a linear invariant\n\nand if upwind operators (D_3 = D_1+ D_1 D_1-) or wide-stencil operators (D_3 = D_1^3) are used for the third derivative, it also conserves\n\nthe energy (integral of 12eta^2)\n\nfor periodic boundary conditions.\n\nDiederik Korteweg and Gustav de Vries (1895) On the change of form of long waves advancing in a rectangular canal, and on a new type of long stationary waves DOI: 10.1080/14786449508620739\nAbhijit Biswas, David I. Ketcheson, Hendrik Ranocha and Jochen Schütz (2025) Traveling-Wave Solutions and Structure-Preserving Numerical Methods for a Hyperbolic Approximation of the Korteweg-de Vries Equation DOI: 10.1007/s10915-025-02898-x\n\n\n\n\n\n","category":"type"},{"location":"overview/#BBM-BBM","page":"Overview","title":"BBM-BBM","text":"","category":"section"},{"location":"overview/#DispersiveShallowWater.BBMBBMEquations1D","page":"Overview","title":"DispersiveShallowWater.BBMBBMEquations1D","text":"BBMBBMEquations1D(; bathymetry_type = bathymetry_variable,\n                  gravity, eta0 = 0.0)\n\nBBM-BBM (Benjamin–Bona–Mahony) system in one spatial dimension. The equations for flat bathymetry are given by\n\nbeginaligned\n  eta_t + ((eta + D)v)_x - frac16D^2eta_xxt = 0\n  v_t + geta_x + left(frac12v^2right)_x - frac16D^2v_xxt = 0\nendaligned\n\nThe unknown quantities of the BBM-BBM equations are the total water height eta and the velocity v. The gravitational acceleration gravity is denoted by g and the constant bottom topography (bathymetry) b = eta_0 - D. The water height above the bathymetry is therefore given by h = eta - eta_0 + D. The BBM-BBM equations are only implemented for eta_0 = 0.\n\nTwo types of bathymetry_type are supported:\n\nbathymetry_flat: flat bathymetry (typically b = 0 everywhere)\nbathymetry_variable: general variable bathymetry\n\nFor the general case of variable vathymetry the BBM-BBM equations are\n\nbeginaligned\n  eta_t + ((eta + D)v)_x - frac16(D^2eta_xt)_x = 0\n  v_t + geta_x + left(frac12v^2right)_x - frac16(D^2v_t)_xx = 0\nendaligned\n\nOne reference for the BBM-BBM system can be found in Bona et al. (1998). The semidiscretization implemented here was developed for flat bathymetry in Ranocha et al. (2020) and generalized for a variable bathymetry in Lampert and Ranocha (2024). It conserves\n\nthe total water mass (integral of h) as a linear invariant\nthe total velocity (integral of v) as a linear invariant for flat bathymetry\nthe total energy\n\nfor periodic boundary conditions (see Lampert, Ranocha). For reflecting boundary conditions, the semidiscretization conserves\n\nthe total water (integral of h) as a linear invariant\nthe total energy.\n\nAdditionally, it is well-balanced for the lake-at-rest stationary solution, see Lampert and Ranocha (2024).\n\nJerry L. Bona, Min Chen (1998) A Boussinesq system for two-way propagation of nonlinear dispersive waves DOI: 10.1016/S0167-2789(97)00249-2\nHendrik Ranocha, Dimitrios Mitsotakis, David I. Ketcheson (2020) A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations DOI: 10.4208/cicp.OA-2020-0119\nJoshua Lampert, Hendrik Ranocha (2024) Structure-Preserving Numerical Methods for Two Nonlinear Systems of Dispersive Wave Equations DOI: 10.48550/arXiv.2402.16669\n\n\n\n\n\n","category":"type"},{"location":"overview/#Svärd-Kalisch","page":"Overview","title":"Svärd-Kalisch","text":"","category":"section"},{"location":"overview/#DispersiveShallowWater.SvaerdKalischEquations1D","page":"Overview","title":"DispersiveShallowWater.SvaerdKalischEquations1D","text":"SvaerdKalischEquations1D(; bathymetry_type = bathymetry_variable, gravity,\n                         eta0 = 0.0, alpha = 0.0, beta = 1/3, gamma = 0.0)\n\nDispersive system by Svärd and Kalisch (2023) in one spatial dimension. The equations for variable bathymetry are given in conservative variables by\n\nbeginaligned\n  h_t + (hv)_x = (hatalpha(hatalpha(h + b)_x)_x)_x\n  (hv)_t + (hv^2)_x + gh(h + b)_x = (hatalpha v(hatalpha(h + b)_x)_x)_x + (hatbeta v_x)_xt + frac12(hatgamma v_x)_xx + frac12(hatgamma v_xx)_x\nendaligned\n\nwhere hatalpha^2 = alphasqrtgDD^2, hatbeta = beta D^3, hatgamma = gammasqrtgDD^3. The coefficients alpha, beta and gamma are provided in dimensionless form and D = eta_0 - b is the still-water depth and eta0 is the still-water surface (lake-at-rest). The equations can be rewritten in primitive variables as\n\nbeginaligned\n  eta_t + ((eta + D)v)_x = (hatalpha(hatalphaeta_x)_x)_x\n  v_t(eta + D) - v((eta + D)v)_x + ((eta + D)v^2)_x + g(eta + D)eta_x = (hatalpha v(hatalphaeta_x)_x)_x - v(hatalpha(hatalphaeta_x)_x)_x + (hatbeta v_x)_xt + frac12(hatgamma v_x)_xx + frac12(hatgamma v_xx)_x\nendaligned\n\nThe unknown quantities of the Svärd-Kalisch equations are the total water height eta and the velocity v. The gravitational acceleration gravity is denoted by g and the bottom topography (bathymetry) b = eta_0 - D. The water height above the bathymetry is therefore given by h = eta - eta_0 + D.\n\nCurrently, the equations only support a general variable bathymetry, see bathymetry_variable.\n\nSvärdKalischEquations1D is an alias for SvaerdKalischEquations1D.\n\nThe equations by Svärd and Kalisch are presented and analyzed in Svärd and Kalisch (2025). The semidiscretization implemented here conserves\n\nthe total water mass (integral of h) as a linear invariant\nthe total momentum (integral of h v) as a nonlinear invariant for flat bathymetry\nthe total modified energy\n\nfor periodic boundary conditions (see Lampert, Ranocha). Additionally, it is well-balanced for the lake-at-rest stationary solution, see Lampert and Ranocha (2024).\n\nMagnus Svärd, Henrik Kalisch (2025) A novel energy-bounded Boussinesq model and a well-balanced and stable numerical discretization arXiv: 2302.09924, DOI: 10.1016/j.jcp.2024.113516\nJoshua Lampert, Hendrik Ranocha (2024) Structure-Preserving Numerical Methods for Two Nonlinear Systems of Dispersive Wave Equations DOI: 10.48550/arXiv.2402.16669\n\n\n\n\n\n","category":"type"},{"location":"overview/#DispersiveShallowWater.SvärdKalischEquations1D","page":"Overview","title":"DispersiveShallowWater.SvärdKalischEquations1D","text":"SvärdKalischEquations1D\n\nSame as SvaerdKalischEquations1D.\n\n\n\n\n\n","category":"type"},{"location":"overview/#Serre-Green-Naghdi","page":"Overview","title":"Serre-Green-Naghdi","text":"","category":"section"},{"location":"overview/#DispersiveShallowWater.SerreGreenNaghdiEquations1D","page":"Overview","title":"DispersiveShallowWater.SerreGreenNaghdiEquations1D","text":"SerreGreenNaghdiEquations1D(; bathymetry_type = bathymetry_variable,\n                            gravity, eta0 = 0.0)\n\nSerre-Green-Naghdi system in one spatial dimension. The equations for flat bathymetry are given by\n\nbeginaligned\n  h_t + (h v)_x = 0\n  h v_t - frac13 (h^3 v_tx)_x + frac12 g (h^2)_x + frac12 h (v^2)_x + p_x = 0\n  p = frac13 h^3 v_x^2 - frac13 h^3 v v_xx\nendaligned\n\nThe unknown quantities of the Serre-Green-Naghdi equations are the total water height eta = h + b and the velocity v. The gravitational acceleration gravity is denoted by g and the bottom topography (bathymetry) b = eta_0 - D. The water height above the bathymetry is therefore given by h = eta - eta_0 + D. The total water height is therefore given by eta = h + b.\n\nThree types of bathymetry_type are supported:\n\nbathymetry_flat: flat bathymetry (typically b = 0 everywhere)\nbathymetry_mild_slope: variable bathymetry with mild-slope approximation\nbathymetry_variable: general variable bathymetry\n\nFor the mild-slope approximation, the Serre-Green-Naghdi equations are\n\nbeginaligned\n  h_t + (h v)_x = 0\n  h v_t - frac13 (h^3 v_tx)_x + frac12 (h^2 b_x v_t)_x - frac12 h^2 b_x v_tx + frac34 h b_x^2 v_t\n    + frac12 g (h^2)_x + g h b_x + frac12 h (v^2)_x\n    + p_x + frac32 fracph b_x = 0\n  p = frac13 h^3 v_x^2 - frac13 h^3 v v_xx\n    + frac12 h^2 v (b_x v)_x\nendaligned\n\nFor the general case of variable bathymetry without mild-slope approximation, the Serre-Green-Naghdi equations are\n\nbeginaligned\n  h_t + (h v)_x = 0\n  h v_t - frac13 (h^3 v_tx)_x + frac12 (h^2 b_x v_t)_x - frac12 h^2 b_x v_tx + h b_x^2 v_t\n    + frac12 g (h^2)_x + g h b_x + frac12 h (v^2)_x\n    + p_x + frac32 fracph b_x + psi b_x = 0\n  p = frac13 h^3 v_x^2 - frac13 h^3 v v_xx\n    + frac12 h^2 v (b_x v)_x\n  psi = frac14 h v (b_x v)_x\nendaligned\n\nReferences for the Serre-Green-Naghdi system can be found in\n\nSerre (1953) Contribution â l'étude des écoulements permanents et variables dans les canaux DOI: 10.1051/lhb/1953034\nGreen and Naghdi (1976) A derivation of equations for wave propagation in water of variable depth DOI: 10.1017/S0022112076002425\n\nThe semidiscretization implemented here conserves\n\nthe total water mass (integral of h) as a linear invariant\nthe total momentum (integral of h v) as a nonlinear invariant if the bathymetry is constant\nthe total modified energy\n\nfor periodic boundary conditions (see Ranocha and Ricchiuto (2024)). Additionally, it is well-balanced for the lake-at-rest stationary solution, see\n\nHendrik Ranocha and Mario Ricchiuto (2024) Structure-preserving approximations of the Serre-Green-Naghdi equations in standard and hyperbolic form arXiv: 2408.02665\n\n\n\n\n\n","category":"type"},{"location":"overview/#Hyperbolic-Serre-Green-Naghdi","page":"Overview","title":"Hyperbolic Serre-Green-Naghdi","text":"","category":"section"},{"location":"overview/#DispersiveShallowWater.HyperbolicSerreGreenNaghdiEquations1D","page":"Overview","title":"DispersiveShallowWater.HyperbolicSerreGreenNaghdiEquations1D","text":"HyperbolicSerreGreenNaghdiEquations1D(; bathymetry_type = bathymetry_mild_slope,\n                                      gravity,\n                                      eta0 = 0.0,\n                                      lambda)\n\nHyperbolic approximation of the Serre-Green-Naghdi system in one spatial dimension. The equations for flat bathymetry are given by\n\nbeginaligned\n  h_t + (h v)_x = 0\n  h v_t + frac12 g (h^2)_x + frac12 h (v^2)_x\n    + biggl( fraclambda3 H (1 - H  h) biggr)_x = 0\n  h w_t + h v w_x = lambda (1 - H  h)\n  H_t + H_x u = w\nendaligned\n\nThe unknown quantities of the hyperbolized Serre-Green-Naghdi equations are the total water height eta = h + b and the velocity v. The gravitational acceleration gravity is denoted by g and the bottom topography (bathymetry) b = eta_0 - D. The water height above the bathymetry is therefore given by h = eta - eta_0 + D. The total water height is therefore given by eta = h + b.\n\nThere are two additional variables w approx -h v_x and H approx h compared to the SerreGreenNaghdiEquations1D. In the original papers of Gavrilyuk et al., the variable H is called eta. Here, we use eta for the total water height and H for auxiliary variable introduced in the hyperbolic approximation.\n\nnote: Initial conditions\nThe HyperbolicSerreGreenNaghdiEquations1D allow two options for specifying initial conditions:Returning the full set of variables q = (η, v, D, w, H)\nReturning a reduced set of variables q = (η, v, D) as required for the limit system SerreGreenNaghdiEquations1D of the hyperbolic approximation. The remaining variables w and H are initialized using the default initialization w approx -h v_x and H approx h using the derivative operator of the solver.\n\nThe relaxation parameter lambda (lambda) introduced to obtain this hyperbolic approximation of the SerreGreenNaghdiEquations1D influences the stiffness of the system. For lambda to infty, the hyperbolic Serre-Green-Naghdi equations converge (at least formally) to the original SerreGreenNaghdiEquations1D. However, the wave speeds of the hyperbolic system increase with increasing lambda, so that explicit time integration methods become more expensive.\n\nTwo types of bathymetry_type are supported:\n\nbathymetry_flat: flat bathymetry (typically b = 0 everywhere)\nbathymetry_mild_slope: variable bathymetry with mild-slope approximation\n\nFor the mild-slope approximation, the Serre-Green-Naghdi equations are\n\nbeginaligned\n  h_t + (h v)_x = 0\n  h v_t + frac12 g (h^2)_x + frac12 h (v^2)_x\n    + biggl( fraclambda3 H (1 - H  h) biggr)_x\n    + biggl( g h + fraclambda2 (1 - H  h) biggr) b_x = 0\n  h w_t + h v w_x = lambda (1 - H  h)\n  H_t + H_x u + frac32 b_x v = w\nendaligned\n\nReferences for the hyperbolized Serre-Green-Naghdi system can be found in\n\nFavrie and Gavrilyuk. A rapid numerical method for solving Serre-Green-Naghdi equations describing long free surface gravity waves DOI: 10.1088/1361-6544/aa712d\nBusto, Dumbser, Escalante, Favrie, and Gavrilyuk. On High Order ADER Discontinuous Galerkin Schemes for First Order Hyperbolic Reformulations of Nonlinear Dispersive Systems DOI: 10.1007/s10915-021-01429-8\n\nThe semidiscretization implemented here conserves\n\nthe total water mass (integral of h) as a linear invariant\nthe total modified energy\n\nfor periodic boundary conditions (see Ranocha and Ricchiuto (2024)). Additionally, it is well-balanced for the lake-at-rest stationary solution, see\n\nHendrik Ranocha and Mario Ricchiuto (2024) Structure-preserving approximations of the Serre-Green-Naghdi equations in standard and hyperbolic form arXiv: 2408.02665\n\n\n\n\n\n","category":"type"},{"location":"callbacks/#Callbacks","page":"Callbacks and Relaxation","title":"Callbacks","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"Callbacks provide additional functionality during simulations, such as monitoring solution properties, analyzing errors, or ensuring conservation of physical quantities. DispersiveShallowWater.jl implements three main callback types that can be used individually or in combination to enhance simulation analysis and performance monitoring.","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"When using multiple callbacks simultaneously, combine them using a CallbackSet:","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"callbacks = CallbackSet(analysis_callback, summary_callback)\nsol = solve(ode, Tsit5(), callback = callbacks)","category":"page"},{"location":"callbacks/#Summary-Callback","page":"Callbacks and Relaxation","title":"Summary Callback","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"The SummaryCallback provides performance profiling information at the end of a simulation. It tracks computational time spent in different parts of the code and memory allocations, giving insights into the computational efficiency of the simulation.","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"The callback automatically prints a detailed timing breakdown showing:","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"Total simulation time and memory allocations\nTime spent in different computational sections\nNumber of function calls and average execution time per call","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"summary_callback = SummaryCallback()\nsol = solve(ode, Tsit5(), callback = summary_callback)","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"At the end of the simulation, the callback will display output similar to:","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"───────────────────────────────────────────────────────────────────────────────────────────\n              DispersiveSWE                       Time                    Allocations\n                                         ───────────────────────   ────────────────────────\n            Tot / % measured:                 440ms /  98.4%            867MiB /  99.9%\n\nSection                          ncalls     time    %tot     avg     alloc    %tot      avg\n───────────────────────────────────────────────────────────────────────────────────────────\nrhs!                              1.62k    420ms   97.0%   258μs    866MiB  100.0%   546KiB\n  solving elliptic system         1.62k    247ms   57.2%   152μs    357MiB   41.2%   225KiB\n  assembling elliptic operator    1.62k    167ms   38.6%   103μs    509MiB   58.8%   321KiB\n  hyperbolic terms                1.62k   3.49ms    0.8%  2.15μs     0.00B    0.0%    0.00B\n  ~rhs!~                          1.62k   1.46ms    0.3%   902ns   1.55KiB    0.0%    0.98B\n  source terms                    1.62k   42.0μs    0.0%  25.9ns     0.00B    0.0%    0.00B\nanalyze solution                      3   13.2ms    3.0%  4.39ms    147KiB    0.0%  49.1KiB\n───────────────────────────────────────────────────────────────────────────────────────────","category":"page"},{"location":"callbacks/#Analysis-Callback","page":"Callbacks and Relaxation","title":"Analysis Callback","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"The AnalysisCallback monitors solution quality and physical properties during the simulation. It computes error norms and tracks conservation of important physical quantities at specified time intervals.","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"First, let's set up a basic simulation using the BBM-BBM equations:","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"using DispersiveShallowWater, OrdinaryDiffEqTsit5\n\n# Define the physical setup\nequations = BBMBBMEquations1D(gravity = 9.81)\n\ninitial_condition = initial_condition_convergence_test\n\n# Create mesh and solver\ncoordinates_min = -35.0\ncoordinates_max = 35.0\nN = 512\nmesh = Mesh1D(coordinates_min, coordinates_max, N)\naccuracy_order = 8\nsolver = Solver(mesh, accuracy_order)\n\n# Create semidiscretization\nsemi = Semidiscretization(mesh, equations, initial_condition, solver,\n                          boundary_conditions = boundary_condition_periodic)\nnothing # hide","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"The analysis callback computes L^2 and L^infty errors by comparing the numerical solution to the initial condition at time t (which can be the analytical solution, if available). Additional error types can be specified using the extra_analysis_errors parameter, and physical quantities can be monitored using extra_analysis_integrals.","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"The conservation error measures the temporal change of conserved quantities. For the BBM-BBM equations, important conserved quantities include the total water mass (integral of water height h), the total momentum (integral of v for flat bathymetry), and the entropy. The specific form of the entropy varies between different equation systems. For the BBM-BBM equations, the entropy is:","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"mathcal E(t eta v) = frac12int_Omega geta^2 + (eta + D)v^2  dx","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"where eta is the total water height and D is the still-water depth.","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"tspan = (0.0, 20.0)\node = semidiscretize(semi, tspan)\n\nanalysis_callback = AnalysisCallback(semi; interval = 10,\n                                     extra_analysis_errors = (:conservation_error,),\n                                     extra_analysis_integrals = (waterheight_total,\n                                                                 velocity, entropy),\n                                     io = devnull)\n\nsaveat = range(tspan..., length = 100)\nsol = solve(ode, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n            save_everystep = false, callback = analysis_callback, saveat = saveat)\nnothing # hide","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"The recorded errors and integrals can be accessed as NamedTuples using errors(analysis_callback) and integrals(analysis_callback).","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"The temporal evolution of monitored quantities can be visualized by plotting the analysis callback:","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"using Plots\n# default(grid=true, box=:on, dpi=100, titlefont=font(16), linewidth=3, gridlinewidth=2, markersize=4, markerstrokewidth=2, xtickfontsize=14, ytickfontsize=14, xguidefontsize=16, yguidefontsize=16, ztickfontsize=14, zguidefontsize=16, legendfontsize=14) # hide\n\nplot(analysis_callback)\nsavefig(\"analysis_callback.png\") # hide\nnothing # hide","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"(Image: analysis callback)","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"The plot shows that linear invariants such as the total water mass and total velocity are conserved exactly. However, nonlinear invariants such as the entropy may exhibit small growth over time. This occurs because standard time integration methods do not necessarily preserve nonlinear invariants, even when the spatial discretization is conservative.","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"For a fully discrete entropy-conservative method, see also the following section about relaxation and the RelaxationCallback.","category":"page"},{"location":"callbacks/#Relaxation-Callback","page":"Callbacks and Relaxation","title":"Relaxation Callback","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"To obtain entropy-conserving time-stepping schemes, DispersiveShallowWater.jl uses the relaxation method introduced in [Ketcheson2019] and further developed in [RanochaSayyariDalcinParsaniKetcheson2020]. The relaxation method is implemented as a RelaxationCallback, which takes a function representing the conserved quantity as the keyword argument invariant. This callback modifies the time step to maintain conservation of a specified quantity.","category":"page"},{"location":"callbacks/#Entropy-Conserving-Time-Integration","page":"Callbacks and Relaxation","title":"Entropy-Conserving Time Integration","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"To achieve exact conservation of the entropy, we add a relaxation callback to the simulation:","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"analysis_callback2 = AnalysisCallback(semi; interval = 10,\n                                      extra_analysis_errors = (:conservation_error,),\n                                      extra_analysis_integrals = (waterheight_total,\n                                                                  velocity, entropy),\n                                      io = devnull)\nrelaxation_callback = RelaxationCallback(invariant = entropy)\n\n# Important: RelaxationCallback must come before AnalysisCallback\ncallbacks = CallbackSet(relaxation_callback, analysis_callback2)\nsol = solve(ode, Tsit5(), abstol = 1e-7, reltol = 1e-7,\n            save_everystep = false, callback = callbacks, saveat = saveat)\nnothing # hide","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"note: Callback Ordering\nWhen using both RelaxationCallback and AnalysisCallback, the relaxation callback must be placed first in the CallbackSet. This ensures that the analysis callback monitors the solution after the relaxation step has been applied.","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"The relaxation method modifies each time step by finding an optimal relaxation parameter that preserves the specified invariant exactly. This results in entropy conservation almost up to machine precision and therefore provides a fully discrete structure-preserving numerical scheme:","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"plot(analysis_callback2, ylims = (-4e-12, 4e-12))\nsavefig(\"analysis_callback_relaxation.png\") # hide\nnothing # hide","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"(Image: analysis callback relaxation)","category":"page"},{"location":"callbacks/#Relaxation","page":"Callbacks and Relaxation","title":"Relaxation","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"For a semidiscretization, which conserves a nonlinear invariant, the relaxation method conserves this nonlinear invariant up to machine precision also in the temporal discretization with minimal computational overhead. This can improve solution stability and accuracy, often reducing error growth over time from quadratic to linear.","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"The following comparison shows error growth with and without the relaxation method using the above simulation setup. For the comparison, it is important that we use a high accuracy order of our spatial discretization and sufficiently fine grid resolution. Otherwise, spatial discretization errors will dominate the total error, making it difficult to observe the improvements that relaxation provides to the temporal error behavior.","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"plot(analysis_callback2, what = (:errors,), exclude = (:conservation_error, :linf_error),\n     label = \"L2 error with relaxation\")\nplot!(analysis_callback, what = (:errors,), exclude = (:conservation_error, :linf_error),\n      label = \"L2 error without relaxation\")\n\n\nsavefig(\"error_growth_relaxation.png\") # hide\nnothing # hide","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"(Image: error growth relaxation)","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"For additional information on relaxation, how it works, and why and when it is useful, see Ranocha et al. (2020).","category":"page"},{"location":"callbacks/#References","page":"Callbacks and Relaxation","title":"References","text":"","category":"section"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"[Ketcheson2019]: Ketcheson (2019): Relaxation Runge-Kutta Methods: Conservation and stability for Inner-Product Norms. DOI: 10.1137/19M1263662","category":"page"},{"location":"callbacks/","page":"Callbacks and Relaxation","title":"Callbacks and Relaxation","text":"[RanochaSayyariDalcinParsaniKetcheson2020]: Ranocha, Sayyari, Dalcin, Parsani, Ketcheson (2020): Relaxation Runge–Kutta Methods: Fully-Discrete Explicit Entropy-Stable Schemes for the Compressible Euler and Navier–Stokes Equations. DOI: 10.1137/19M1263480","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using DispersiveShallowWater, OrdinaryDiffEqTsit5# hide\nequations = BBMBBMEquations1D(gravity = 9.81)# hide\n# hide\ninitial_condition = initial_condition_convergence_test# hide\n# hide\n# Create mesh and solver# hide\ncoordinates_min = -10.0# hide\ncoordinates_max = 10.0# hide\nN = 128# hide\nmesh = Mesh1D(coordinates_min, coordinates_max, N)# hide\nsolver = Solver(mesh, 4)# hide\n# hide\n# Create semidiscretization# hide\nsemi = Semidiscretization(mesh, equations, initial_condition, solver,# hide\n                          boundary_conditions = boundary_condition_periodic)# hide\n                          tspan = (0.0, 20.0)# hide\node = semidiscretize(semi, tspan)# hide\n# hide\nanalysis_callback = AnalysisCallback(semi; interval = 10,# hide\n                                     extra_analysis_errors = (:conservation_error,),# hide\n                                     extra_analysis_integrals = (waterheight_total,# hide\n                                                                 velocity, entropy),# hide\n                                     io = devnull)# hide\n# hide\nsaveat = range(tspan..., length = 100)# hide\nsol = solve(ode, Tsit5(), abstol = 1e-7, reltol = 1e-7,# hide\n            save_everystep = false, callback = analysis_callback, saveat = saveat)# hide\nanalysis_callback2 = AnalysisCallback(semi; interval = 10,# hide\n                                     extra_analysis_errors = (:conservation_error,),# hide\n                                     extra_analysis_integrals = (waterheight_total,# hide\n                                                                 velocity, entropy),# hide\n                                     io = devnull)# hide\nrelaxation_callback = RelaxationCallback(invariant = entropy)# hide\ncallbacks = CallbackSet(relaxation_callback, analysis_callback2)# hide\nsol = solve(ode, Tsit5(), abstol = 1e-7, reltol = 1e-7,# hide\n            save_everystep = false, callback = callbacks, saveat = saveat)# hide\n\nnothing # hide","category":"page"},{"location":"plotting/#plotting","page":"Plotting","title":"Plotting Simulation Results","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"DispersiveShallowWater.jl provides flexible plotting capabilities through Plots.jl recipes. The plotting system supports various conversion functions, visualization options, and analysis tools. ","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Makie.jl is not supported yet. Contributions are welcome.","category":"page"},{"location":"plotting/#Variable-Conversion-and-Visualization-Options","page":"Plotting","title":"Variable Conversion and Visualization Options","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The plotting system supports different variable conversions and visualization options. You can plot conservative variables, specific physical quantities, and control what additional information is displayed:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"using Plots\n# default(grid=true, box=:on, dpi=100, titlefont=font(16), linewidth=3, gridlinewidth=2, markersize=4, markerstrokewidth=2, xtickfontsize=14, ytickfontsize=14, xguidefontsize=16, yguidefontsize=16, ztickfontsize=14, zguidefontsize=16, legendfontsize=14) # hide\n\n# Plot different variable representations\n\nt = 13.37 # plot solution at (roughly) t = 13.37s\nstep_idx = argmin(abs.(saveat .- t)) # get the closest point to 13.37\np1 = plot(semi => sol, conversion = prim2prim, plot_bathymetry = false, \n          suptitle = \"Primitive Variables\", step = step_idx)\np2 = plot(semi => sol, conversion = prim2cons, plot_bathymetry = false,\n          suptitle = \"Conservative Variables\", step = step_idx)\np3 = plot(semi => sol, conversion = waterheight_total, plot_bathymetry = true,\n          suptitle = \"Total Water Height\", step = step_idx)\np4 = plot(semi => sol, conversion = velocity, plot_initial = true, plot_bathymetry = false,\n          suptitle = \"Velocity with Initial Condition\", step = step_idx)\n\nplot(p1, p2, p3, p4, layout = (2, 2), size = (1000, 700))\nsavefig(\"variable_conversions.png\") # hide\nnothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: variable conversions)","category":"page"},{"location":"plotting/#Time-Series-Analysis-at-Spatial-Points","page":"Plotting","title":"Time Series Analysis at Spatial Points","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"You can analyze the temporal evolution of the solution at specific spatial locations. This is particularly useful for understanding wave propagation and local dynamics:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# Analyze solution at a single spatial point\nx_location = 0.0\n\np1 = plot(semi => sol, x_location, conversion = waterheight_total,\n          suptitle = \"Water Height Evolution at x = $x_location\")\n\np2 = plot(semi => sol, x_location, conversion = velocity,\n          suptitle = \"Velocity Evolution at x = $x_location\")\n\nplot(p1, p2, layout = (1, 2), size = (800, 400))\nsavefig(\"time_series_analysis.png\") # hide\nnothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: time series analysis)","category":"page"},{"location":"plotting/#Energy-and-Momentum-Evolution","page":"Plotting","title":"Energy and Momentum Evolution","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"Using the analysis callback results, we can visualize how conserved quantities evolve over time. The built-in plotting recipe shows the change of each invariant from its initial value:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# Plot conservation properties using the built-in recipe\n# This shows how each conserved quantity deviates from its initial value over time\nplot(analysis_callback2, exclude = (:velocity,))\nsavefig(\"conservation_analysis.png\") # hide\nnothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: conservation analysis)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The plot shows the change of invariants over time (i.e., integral(t) - integral(t=0)). The exclude parameter allows you to hide specific quantities from the plot - here we exclude velocity to focus on other conserved quantities.","category":"page"},{"location":"plotting/#Error-Analysis-Visualization","page":"Plotting","title":"Error Analysis Visualization","text":"","category":"section"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The error analysis compares the numerical solution with the initial condition evaluated at time t. Note that this represents the analytical solution only if the initial condition function describes an exact solution that varies with time:","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"# Plot error evolution using the built-in recipe\n# The 'what' parameter controls what gets plotted: (:integrals,), (:errors,), or both\n# The 'exclude' parameter removes specific error types from the plot\nplot(analysis_callback2, what = (:errors,), exclude = (:conservation_error,))\nsavefig(\"error_analysis.png\") # hide\nnothing # hide","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"(Image: error analysis)","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The what = (:errors,) parameter tells the plotting recipe to show errors instead of the default invariants. The errors plotted are the total errors summed over all variables (L² and L∞ norms). The exclude = (:conservation_error,) parameter removes the conservation error from the plot, focusing only on the discretization errors (L² and L∞).","category":"page"},{"location":"plotting/","page":"Plotting","title":"Plotting","text":"The plotting system supports all standard Plots.jl features like custom color schemes, annotations, and interactive backends. For more advanced plotting options, consult the Plots.jl documentation.","category":"page"},{"location":"ref/#DispersiveShallowWater.jl-API","page":"DispersiveShallowWater","title":"DispersiveShallowWater.jl API","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.DispersiveShallowWater","page":"DispersiveShallowWater","title":"DispersiveShallowWater.DispersiveShallowWater","text":"DispersiveShallowWater\n\nDispersiveShallowWater.jl is a Julia package that implements structure-preserving numerical methods for dispersive shallow water models. It provides provably conservative, entropy-conserving, and well-balanced numerical schemes for some dispersive shallow water models.\n\nThe semidiscretizations are based on summation-by-parts (SBP) operators, which are implemented in SummationByPartsOperators.jl. To obtain fully discrete schemes, the time integration methods from OrdinaryDiffEq.jl are used to solve the resulting ordinary differential equations. Fully discrete entropy-conservative methods can be obtained by using the relaxation method provided by DispersiveShallowWater.jl.\n\nSee also: DispersiveShallowWater.jl\n\n\n\n\n\n","category":"module"},{"location":"ref/#Model-specific-equations","page":"DispersiveShallowWater","title":"Model specific equations","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.energy_total_modified!-Tuple{Any, Any, BBMEquation1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total_modified!","text":"energy_total_modified!(e, q_global, equations::BBMEquation1D, cache)\n\nReturn the modified total energy e of the primitive variables q_global for the BBMEquation1D. The energy_total_modified is a conserved quantity (for periodic boundary conditions).\n\nIt is given by\n\nfrac12 eta(eta - frac16D^2eta_xx)\n\nq_global is a vector of the primitive variables at ALL nodes. cache needs to hold the SBP operators used by the solver.\n\nSee also energy_total_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.hamiltonian!-Tuple{Any, Any, BBMEquation1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.hamiltonian!","text":"hamiltonian!(H, q_global, equations::BBMEquation1D, cache)\n\nReturn the Hamiltonian H of the primitive variables q_global for the BBMEquation1D. The Hamiltonian is given by\n\nfrac14sqrtfracgDeta^3 + frac12sqrtgDeta^2\n\nq_global is a vector of the primitive variables at ALL nodes.\n\nSee also hamiltonian.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_convergence_test-Tuple{Any, Any, BBMEquation1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::BBMEquation1D, mesh)\n\nA traveling-wave solution used for convergence tests in a periodic domain, here generalized for dimensional variables.\n\nSee section 4.1.3 in (there is an error in paper: it should be sech^2 instead of cosh):\n\nHendrik Ranocha, Dimitrios Mitsotakis and David I. Ketcheson (2020) A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations DOI: 10.4208/cicp.OA-2020-0119\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured-Tuple{Any, Any, BBMEquation1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured","text":"initial_condition_manufactured(x, t, equations::BBMEquation1D, mesh)\n\nA smooth manufactured solution in combination with source_terms_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured-Tuple{Any, Any, Any, BBMEquation1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured","text":"source_terms_manufactured(q, x, t, equations::BBMEquation1D)\n\nA smooth manufactured solution in combination with initial_condition_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_convergence_test-Tuple{Any, Any, BBMBBMEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::BBMBBMEquations1D, mesh)\n\nA traveling-wave solution used for convergence tests in a periodic domain. The bathymetry is constant.\n\nFor details see Example 5 in Section 3 from (here adapted for dimensional equations):\n\nMin Chen (1997) Exact Traveling-Wave Solutions to Bidirectional Wave Equations DOI: 10.1023/A:1026667903256\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_dingemans-Tuple{Any, Any, BBMBBMEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_dingemans","text":"initial_condition_dingemans(x, t, equations::BBMBBMEquations1D, mesh)\n\nThe initial condition that uses the dispersion relation of the Euler equations to approximate waves generated by a wave maker as it is done by experiments of Dingemans. The topography is a trapezoidal.\n\nwarning: Translation of water height\nThe initial condition for the water height is translated to be around 0, which is needed for the simulation because the BBMBBMEquations1D are only implemented for eta_0 = 0.\n\nReferences:\n\nMagnus Svärd, Henrik Kalisch (2023) A novel energy-bounded Boussinesq model and a well-balanced and stable numerical discretization arXiv: 2302.09924\nMaarten W. Dingemans (1994) Comparison of computations with Boussinesq-like models and laboratory measurements link\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured-Tuple{Any, Any, BBMBBMEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured","text":"initial_condition_manufactured(x, t, equations::BBMBBMEquations1D, mesh)\n\nA smooth manufactured solution in combination with source_terms_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured_reflecting-Tuple{Any, Any, BBMBBMEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured_reflecting","text":"initial_condition_manufactured_reflecting(x, t, equations::BBMBBMEquations1D, mesh)\n\nA smooth manufactured solution for reflecting boundary conditions in combination with source_terms_manufactured_reflecting.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured-Tuple{Any, Any, Any, BBMBBMEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured","text":"source_terms_manufactured(q, x, t, equations::BBMBBMEquations1D)\n\nA smooth manufactured solution in combination with initial_condition_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured_reflecting-Tuple{Any, Any, Any, BBMBBMEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured_reflecting","text":"source_terms_manufactured_reflecting(q, x, t, equations::BBMBBMEquations1D)\n\nA smooth manufactured solution for reflecting boundary conditions in combination with initial_condition_manufactured_reflecting.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.bathymetry_flat","page":"DispersiveShallowWater","title":"DispersiveShallowWater.bathymetry_flat","text":"bathymetry_flat = DispersiveShallowWater.BathymetryFlat()\n\nA singleton struct indicating a flat bathymetry.\n\nSee also bathymetry_mild_slope and bathymetry_variable.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#DispersiveShallowWater.bathymetry_mild_slope","page":"DispersiveShallowWater","title":"DispersiveShallowWater.bathymetry_mild_slope","text":"bathymetry_mild_slope = DispersiveShallowWater.BathymetryMildSlope()\n\nA singleton struct indicating a variable bathymetry with mild-slope approximation. Typically, this means that some terms like b_x^2 are neglected.\n\nSee also bathymetry_flat and bathymetry_variable.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#DispersiveShallowWater.bathymetry_variable","page":"DispersiveShallowWater","title":"DispersiveShallowWater.bathymetry_variable","text":"bathymetry_variable = DispersiveShallowWater.BathymetryVariable()\n\nA singleton struct indicating a variable bathymetry (without mild-slope approximation).\n\nSee also bathymetry_flat and bathymetry_mild_slope.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#DispersiveShallowWater.AbstractEquations","page":"DispersiveShallowWater","title":"DispersiveShallowWater.AbstractEquations","text":"AbstractEquations{NDIMS, NVARS}\n\nAn abstract supertype of specific equations such as the BBM-BBM equations. The type parameters encode the number of spatial dimensions (NDIMS) and the number of primary variables (NVARS) of the physics model.\n\nSee also AbstractShallowWaterEquations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.AbstractShallowWaterEquations","page":"DispersiveShallowWater","title":"DispersiveShallowWater.AbstractShallowWaterEquations","text":"AbstractShallowWaterEquations{NDIMS, NVARS}\n\nAn abstract supertype of all equation system that contain the classical shallow water equations as a subsystem, e.g., the BBMBBMEquations1D, the SvaerdKalischEquations1D, and the SerreGreenNaghdiEquations1D. In 1D, the shallow water equations with flat bathymetry are given by\n\nbeginaligned\n  h_t + (h v)_x = 0\n  h v_t + frac12 g (h^2)_x + frac12 h (v^2)_x = 0\nendaligned\n\nwhere h is the waterheight, v the velocity, and g the gravity.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.bathymetry-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.bathymetry","text":"bathymetry(q, equations)\n\nReturn the bathymetry of the primitive variables q for a given set of equations.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.cons2prim-Tuple{Any, AbstractShallowWaterEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.cons2prim","text":"cons2prim(u, equations)\n\nConvert the conserved variables u to the primitive variables for a given set of equations. u is a vector type of the correct length nvariables(equations). Notice the function doesn't include any error checks for the purpose of efficiency, so please make sure your input is correct. The inverse conversion is performed by prim2cons.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.default_analysis_errors-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.default_analysis_errors","text":"default_analysis_errors(equations)\n\nDefault analysis errors used by the AnalysisCallback.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.default_analysis_integrals-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.default_analysis_integrals","text":"default_analysis_integrals(equations)\n\nDefault analysis integrals used by the AnalysisCallback.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.discharge-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.discharge","text":"discharge(q, equations)\n\nSee momentum.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.eachvariable-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.eachvariable","text":"eachvariable(equations::AbstractEquations)\n\nReturn an iterator over the indices that specify the location in relevant data structures for the variables in equations. In particular, not the variables themselves are returned.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.energy_total-Tuple{Any, AbstractShallowWaterEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total","text":"energy_total(q, equations)\n\nReturn the total energy of the primitive variables q for a given set of equations. For all AbstractShallowWaterEquations, the total energy is given by the sum of the kinetic and potential energy of the shallow water subsystem, i.e.,\n\nfrac12 h v^2 + frac12 g eta^2\n\nin 1D, where h is the waterheight, eta = h + b the waterheight_total, v the velocity, and g the gravity.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.energy_total_modified!-Tuple{Any, Any, DispersiveShallowWater.AbstractEquations, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total_modified!","text":"energy_total_modified!(e, q_global, equations, cache)\n\nIn-place version of energy_total_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.energy_total_modified-Tuple{Any, DispersiveShallowWater.AbstractEquations, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total_modified","text":"energy_total_modified(q_global, equations, cache)\n\nReturn the modified total energy of the primitive variables q_global for the equations. This modified total energy is a conserved quantity and can contain additional terms compared to the usual energy_total. For example, for the SvaerdKalischEquations1D and the SerreGreenNaghdiEquations1D, it contains additional terms depending on the derivative of the velocity v_x modeling non-hydrostatic contributions. For equations which are not AbstractShallowWaterEquations, the modified total energy does not have to be an extension of the usual energy_total and does not have to be related to a physical energy. However, it is still a conserved quantity for appropriate boundary conditions and may contain derivatives of the solution.\n\nq_global is a vector of the primitive variables at ALL nodes. cache needs to hold the SBP operators used by the solver if non-hydrostatic terms are present.\n\nInternally, this function allocates a vector for the output and calls DispersiveShallowWater.energy_total_modified!.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.entropy-Tuple{Any, AbstractShallowWaterEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.entropy","text":"entropy(q, equations)\n\nReturn the entropy of the primitive variables q for a given set of equations. For all AbstractShallowWaterEquations, the entropy is just the energy_total.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.entropy_modified!-NTuple{4, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.entropy_modified!","text":"entropy_modified!(e, q_global, equations, cache)\n\nIn-place version of entropy_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.entropy_modified-Tuple{Any, DispersiveShallowWater.AbstractEquations, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.entropy_modified","text":"entropy_modified(q_global, equations, cache)\n\nAlias for energy_total_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.get_name-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.get_name","text":"get_name(equations::AbstractEquations)\n\nReturn the canonical, human-readable name for the given system of equations.\n\nExamples\n\njulia> DispersiveShallowWater.get_name(BBMBBMEquations1D(gravity=1.0))\n\"BBMBBMEquations1D-BathymetryVariable\"\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.gravity-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.gravity","text":"gravity(equations)\n\nReturn the gravitational acceleration g for a given set of equations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.hamiltonian-Tuple{Any, DispersiveShallowWater.AbstractEquations, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.hamiltonian","text":"hamiltonian(q_global, equations, cache)\n\nReturn the Hamiltonian of the primitive variables q_global for the equations. The Hamiltonian is a conserved quantity and may contain derivatives of the solution.\n\nq_global is a vector of the primitive variables at ALL nodes. cache needs to hold the SBP operators used by the solver if non-hydrostatic terms are present.\n\nInternally, this function allocates a vector for the output and calls DispersiveShallowWater.hamiltonian!.\n\nnote: Note\nThis function is not necessarily implemented for all equations. See DispersiveShallowWater.hamiltonian! for further details of equations supporting it.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.hyperbolic_approximation_limit-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.hyperbolic_approximation_limit","text":"DispersiveShallowWater.hyperbolic_approximation_limit(equations)\n\nIf the equations are a hyperbolic approximation of another set of equations, return the equations of the limit system. Otherwise, return the input equations.\n\nSee also is_hyperbolic_appproximation and prim2phys.\n\nnote: Implementation details\nThis function is mostly used for some internal dispatch. For example, it allows to return a reduced set of variables from initial conditions for hyperbolic approximations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_dingemans-Tuple{Any, Any, AbstractShallowWaterEquations, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_dingemans","text":"initial_condition_dingemans(x, t, equations::AbstractShallowWaterEquations, mesh)\n\nThe initial condition that uses the dispersion relation of the Euler equations to approximate waves generated by a wave maker as it is done by experiments of Dingemans. The topography is a trapezoidal. It is assumed that equations.eta0 = 0.8.\n\nReferences:\n\nMagnus Svärd, Henrik Kalisch (2023) A novel energy-bounded Boussinesq model and a well-balanced and stable numerical discretization arXiv: 2302.09924\nMaarten W. Dingemans (1994) Comparison of computations with Boussinesq-like models and laboratory measurements link\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_discontinuous_well_balancedness-Tuple{Any, Any, AbstractShallowWaterEquations, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_discontinuous_well_balancedness","text":"initial_condition_discontinuous_well_balancedness(x, t, equations::AbstractShallowWaterEquations, mesh)\n\nSetup a truly discontinuous bottom topography function for this academic lake-at-rest test case of well-balancedness, i.e. eta is constant and v is zero everywhere. The error for this lake-at-rest test case ∫|η-η₀| should be around machine roundoff.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.is_hyperbolic_appproximation-Tuple{DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.is_hyperbolic_appproximation","text":"DispersiveShallowWater.is_hyperbolic_appproximation(equations)\n\nReturns Val{true}() if the equations are a hyperbolic approximation of another set of equations and Val{false}() otherwise (default). For example, the HyperbolicSerreGreenNaghdiEquations1D are a hyperbolic approximation of the SerreGreenNaghdiEquations1D.\n\nSee also hyperbolic_approximation_limit and prim2phys.\n\nnote: Implementation details\nThis function is mostly used for some internal dispatch. For example, it allows to return a reduced set of variables from initial conditions for hyperbolic approximations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.lake_at_rest_error-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.lake_at_rest_error","text":"lake_at_rest_error(q, equations)\n\nCalculate the error for the \"lake-at-rest\" test case where the waterheight_total eta = h + b should be a constant value over time (given by the value eta_0 passed to the equations when constructing them).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.momentum-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.momentum","text":"momentum(q, equations)\n\nReturn the momentum/discharge of the primitive variables q for a given set of equations, i.e., the waterheight times the velocity.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.prim2cons-Tuple{Any, AbstractShallowWaterEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.prim2cons","text":"prim2cons(q, equations)\n\nConvert the primitive variables q to the conserved variables for a given set of equations. q is a vector type of the correct length nvariables(equations). Notice the function doesn't include any error checks for the purpose of efficiency, so please make sure your input is correct. The inverse conversion is performed by cons2prim.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.prim2phys-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.prim2phys","text":"prim2phys(q, equations)\n\nConvert the primitive variables q to the physically meaningful variables for a given set of equations. By default, this is the same as prim2prim for most equations. However, some equations like the HyperbolicSerreGreenNaghdiEquations1D return a reduced set of variables since they are a hyperbolic approximation of another set of equations (in this case the SerreGreenNaghdiEquations1D).\n\nSee also is_hyperbolic_appproximation and hyperbolic_approximation_limit.\n\nq is a vector type of the correct length nvariables(equations). Notice the function doesn't include any error checks for the purpose of efficiency, so please make sure your input is correct.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.prim2prim-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.prim2prim","text":"prim2prim(q, equations)\n\nReturn the primitive variables q. While this function is as trivial as identity, it is also as useful.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.still_water_surface-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.still_water_surface","text":"still_water_surface(q, equations)\n\nReturn the still water surface eta_0 (lake at rest) for a given set of equations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.varnames","page":"DispersiveShallowWater","title":"DispersiveShallowWater.varnames","text":"varnames(conversion_function, equations)\n\nReturn the list of variable names when applying conversion_function to the primitive variables associated to equations. Common choices of the conversion_function are prim2prim, prim2cons, and prim2phys.\n\n\n\n\n\n","category":"function"},{"location":"ref/#DispersiveShallowWater.velocity-Tuple{Any, AbstractShallowWaterEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.velocity","text":"velocity(q, equations)\n\nReturn the velocity of the primitive variables q for a given set of equations.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.waterheight-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.waterheight","text":"waterheight(q, equations)\n\nReturn the waterheight of the primitive variables q for a given set of equations, i.e., the waterheight h above the bathymetry b.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\nSee also waterheight_total, bathymetry.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.waterheight_total-Tuple{Any, DispersiveShallowWater.AbstractEquations}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.waterheight_total","text":"waterheight_total(q, equations)\n\nReturn the total waterheight of the primitive variables q for a given set of equations, i.e., the waterheight h plus the bathymetry b.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of the correct length nvariables(equations).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.energy_total_modified!-Tuple{Any, Any, HyperbolicSerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total_modified!","text":"DispersiveShallowWater.energy_total_modified!(e, q_global, equations::HyperbolicSerreGreenNaghdiEquations1D, cache)\n\nReturn the modified total energy e of the primitive variables q_global for the HyperbolicSerreGreenNaghdiEquations1D. It contains additional terms compared to the usual energy_total modeling non-hydrostatic contributions. The energy_total_modified is a conserved quantity (for periodic boundary conditions).\n\nFor a bathymetry_mild_slope (and a bathymetry_flat), the total modified energy is given by\n\nfrac12 g eta^2 + frac12 h v^2 +\nfrac16 h w^2 + fraclambda6 h (1 - eta  h)^2\n\nq_global is a vector of the primitive variables at ALL nodes.\n\nSee also energy_total_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured-Tuple{Any, Any, HyperbolicSerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured","text":"initial_condition_manufactured(x, t, equations::HyperbolicSerreGreenNaghdiEquations1D, mesh)\n\nA smooth manufactured solution in combination with source_terms_manufactured, see\n\nHendrik Ranocha and Mario Ricchiuto (2024) Structure-preserving approximations of the Serre-Green-Naghdi equations in standard and hyperbolic form arXiv: 2408.02665\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured_reflecting-Tuple{Any, Any, HyperbolicSerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured_reflecting","text":"initial_condition_manufactured_reflecting(x, t, equations::HyperbolicSerreGreenNaghdiEquations1D, mesh)\n\nA smooth manufactured solution for reflecting boundary conditions in combination with source_terms_manufactured_reflecting.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_soliton-Tuple{Any, Any, HyperbolicSerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_soliton","text":"initial_condition_soliton(x, t, equations::HyperbolicSerreGreenNaghdiEquations1D, mesh)\n\nA soliton solution of the SerreGreenNaghdiEquations1D used for convergence tests in a periodic domain. This is physically the same as initial_condition_convergence_test for the SerreGreenNaghdiEquations1D. Please note that this is not an exact solution of the HyperbolicSerreGreenNaghdiEquations1D (only in the limit of the relaxation parameter lambda to infty).\n\nSee also initial_condition_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.prim2phys-Tuple{Any, HyperbolicSerreGreenNaghdiEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.prim2phys","text":"prim2phys(q, equations::HyperbolicSerreGreenNaghdiEquations1D)\n\nReturn the physical variables eta v D used also by the SerreGreenNaghdiEquations1D from the main variables q for the HyperbolicSerreGreenNaghdiEquations1D.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured-Tuple{Any, Any, Any, HyperbolicSerreGreenNaghdiEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured","text":"source_terms_manufactured(q, x, t, equations::HyperbolicSerreGreenNaghdiEquations1D)\n\nA smooth manufactured solution in combination with initial_condition_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured_reflecting-Tuple{Any, Any, Any, HyperbolicSerreGreenNaghdiEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured_reflecting","text":"source_terms_manufactured_reflecting(q, x, t, equations::HyperbolicSerreGreenNaghdiEquations1D)\n\nA smooth manufactured solution in combination with initial_condition_manufactured_reflecting.\n\ncalculated as shown in: https://github.com/NumericalMathematics/DispersiveShallowWater.jl/pull/228#issuecomment-3123350726\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.energy_total-Tuple{Any, KdVEquation1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total","text":"energy_total(q, equations::KdVEquation1D)\n\nReturn the total energy of the primitive variables q for the KdVEquation1D. For the KdV equation, the total energy consists only of the potential energy, given by\n\nfrac12 g eta^2\n\nwhere eta is the waterheight_total and g is the gravity.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of length 1 in this case.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.entropy-Tuple{Any, KdVEquation1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.entropy","text":"entropy(q, equations::KdVEquation1D)\n\nReturn the entropy of the primitive variables q for the KdVEquation1D. For the KdV equation, the entropy is the same as the energy_total.\n\nq is a vector of the primitive variables at a single node, i.e., a vector of length 1 in this case.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_convergence_test-Tuple{Any, Any, KdVEquation1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::KdVEquation1D, mesh)\n\nA soliton solution used for convergence tests in a periodic domain. Same as initial_condition_soliton for the KdVEquation1D.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured-Tuple{Any, Any, KdVEquation1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured","text":"initial_condition_manufactured(x, t, equations::KdVEquation1D, mesh)\n\nA smooth manufactured solution in combination with source_terms_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_soliton-Tuple{Any, Any, KdVEquation1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_soliton","text":"initial_condition_soliton(x, t, equations::KdVEquation1D, mesh)\n\nA classical soliton solution of the KdV equation in dimensional variables. This can be used for convergence tests in a periodic domain, see initial_condition_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.nondim2prim-Tuple{Any, KdVEquation1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.nondim2prim","text":"nondim2prim(u, equations::KdVEquation1D)\n\nConvert the non-dimensional variable u to the primitive/physical variable eta (total water height) for the KdVEquation1D.\n\nThe transformation is given by:\n\neta = D(u - frac23)\n\nwhere D is the still-water depth.\n\nwarning: Parameter constraints\nThis conversion is only valid for equations with specific parameter values:gravity = 4/27 \nD = 3.0 These values ensure the dimensional KdV equation matches the standard  non-dimensional form u_t + u u_x + u_{xxx} = 0.\n\nThis function allows converting solutions from the standard non-dimensional  KdV form commonly found in literature to the dimensional form implemented  in DispersiveShallowWater.jl.\n\nSee also prim2nondim.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.prim2nondim-Tuple{Any, KdVEquation1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.prim2nondim","text":"prim2nondim(eta, equations::KdVEquation1D)\n\nConvert the primitive/physical variable eta (total water height) to the  non-dimensional variable u for the KdVEquation1D.\n\nThe transformation is given by:\n\nu = fracetaD + frac23\n\nwhere D is the still-water depth.\n\nwarning: Parameter constraints\nThis conversion is only valid for equations with specific parameter values:gravity = 4/27 \nD = 3.0These values ensure the dimensional KdV equation matches the standard  non-dimensional form u_t + u u_x + u_{xxx} = 0.\n\nThis function allows converting solutions from the dimensional form implemented  in DispersiveShallowWater.jl to the standard non-dimensional KdV form  commonly found in literature, enabling comparison with theoretical results  and other implementations.\n\nSee also nondim2prim.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured-Tuple{Any, Any, Any, KdVEquation1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured","text":"source_terms_manufactured(q, x, t, equations::KdVEquation1D)\n\nA smooth manufactured solution in combination with initial_condition_manufactured.\n\nHow it was calculated, is described in: https://github.com/NumericalMathematics/DispersiveShallowWater.jl/pull/198#discussion_r2090805751\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.varnames-Tuple{typeof(prim2nondim), KdVEquation1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.varnames","text":"varnames(::typeof(prim2nondim), equations::KdVEquation1D)\n\nReturn variable names (\"u\",) for non-dimensional KdV variables when plotting with conversion = prim2nondim.\n\nSee prim2nondim, varnames.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.energy_total_modified!-Tuple{Any, Any, SerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total_modified!","text":"DispersiveShallowWater.energy_total_modified!(e, q_global, equations::SerreGreenNaghdiEquations1D, cache)\n\nReturn the modified total energy e of the primitive variables q_global for the SerreGreenNaghdiEquations1D. It contains an additional term containing a derivative compared to the usual energy_total modeling non-hydrostatic contributions. The energy_total_modified is a conserved quantity (for periodic boundary conditions).\n\nFor a bathymetry_flat the total modified energy is given by\n\nfrac12 g eta^2 + frac12 h v^2 + frac16 h^3 v_x^2\n\nFor a bathymetry_mild_slope the total modified energy is given by\n\nfrac12 g eta^2 + frac12 h v^2 + frac16 h (-h v_x + 15 v b_x)^2\n\nFor a bathymetry_variable the total modified energy has the additional term\n\n+ frac18 h (v b_x)^2\n\nq_global is a vector of the primitive variables at ALL nodes. cache needs to hold the SBP operators used by the solver.\n\nSee also energy_total_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_convergence_test-Tuple{Any, Any, SerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_convergence_test","text":"initial_condition_convergence_test(x, t, equations::SerreGreenNaghdiEquations1D, mesh)\n\nA soliton solution used for convergence tests in a periodic domain. Same as initial_condition_soliton for the SerreGreenNaghdiEquations1D.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured-Tuple{Any, Any, SerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured","text":"initial_condition_manufactured(x, t, equations::SerreGreenNaghdiEquations1D, mesh)\n\nA smooth manufactured solution in combination with source_terms_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured_reflecting-Tuple{Any, Any, SerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured_reflecting","text":"initial_condition_manufactured_reflecting(x, t, equations::SerreGreenNaghdiEquations1D, mesh)\n\nA smooth manufactured solution for reflecting boundary conditions in combination with source_terms_manufactured_reflecting.\n\nReferences for flat bathymetry\n\nD. Mitsotakis, C. Synolakis, and M. McGuinness (2016) A modified Galerkin/finite element method for the numerical solution of the Serre-Green-Naghdi system. DOI: 10.1002/fld.4293\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_soliton-Tuple{Any, Any, SerreGreenNaghdiEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_soliton","text":"initial_condition_soliton(x, t, equations::SerreGreenNaghdiEquations1D, mesh)\n\nA classical soliton solution of the Serre-Green-Naghdi equations. This can be used for convergence tests in a periodic domain, see initial_condition_convergence_test.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured-Tuple{Any, Any, Any, SerreGreenNaghdiEquations1D{DispersiveShallowWater.BathymetryFlat}}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured","text":"source_terms_manufactured(q, x, t, equations::SerreGreenNaghdiEquations1D)\n\nA smooth manufactured solution in combination with initial_condition_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured_reflecting-Tuple{Any, Any, Any, SerreGreenNaghdiEquations1D{DispersiveShallowWater.BathymetryFlat}}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured_reflecting","text":"source_terms_manufactured_reflecting(q, x, t, equations::SerreGreenNaghdiEquations1D)\n\nA smooth manufactured solution for reflecting boundary conditions in combination with initial_condition_manufactured_reflecting.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.energy_total_modified!-Tuple{Any, Any, SvaerdKalischEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.energy_total_modified!","text":"DispersiveShallowWater.energy_total_modified!(e, q_global, equations::SvaerdKalischEquations1D, cache)\n\nReturn the modified total energy e of the primitive variables q_global for the SvaerdKalischEquations1D. It contains an additional term containing a derivative compared to the usual energy_total modeling non-hydrostatic contributions. The energy_total_modified is a conserved quantity (for periodic boundary conditions).\n\nIt is given by\n\nfrac12 g eta^2 + frac12 h v^2 + frac12 hatbeta v_x^2\n\nq_global is a vector of the primitive variables at ALL nodes. cache needs to hold the SBP operators used by the solver.\n\nSee also energy_total_modified.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured-Tuple{Any, Any, SvaerdKalischEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured","text":"initial_condition_manufactured(x, t, equations::SvaerdKalischEquations1D, mesh)\n\nA smooth manufactured solution in combination with source_terms_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.initial_condition_manufactured_reflecting-Tuple{Any, Any, SvaerdKalischEquations1D, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.initial_condition_manufactured_reflecting","text":"initial_condition_manufactured_reflecting(x, t, equations::SvaerdKalischEquations1D, mesh)\n\nA smooth manufactured solution for reflecting boundary conditions in combination with source_terms_manufactured_reflecting.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured-Tuple{Any, Any, Any, SvaerdKalischEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured","text":"source_terms_manufactured(q, x, t, equations::SvaerdKalischEquations1D)\n\nA smooth manufactured solution in combination with initial_condition_manufactured.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.source_terms_manufactured_reflecting-Tuple{Any, Any, Any, SvaerdKalischEquations1D}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.source_terms_manufactured_reflecting","text":"source_terms_manufactured_reflecting(q, x, t, equations::SvaerdKalischEquations1D)\n\nA smooth manufactured solution for reflecting boundary conditions in combination with initial_condition_manufactured_reflecting.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Linear-dispersion-relations","page":"DispersiveShallowWater","title":"Linear dispersion relations","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.EulerEquations1D","page":"DispersiveShallowWater","title":"DispersiveShallowWater.EulerEquations1D","text":"EulerEquations1D(; gravity, eta0 = 0.0)\n\nA struct representing the 1D Euler equations with a given gravitational acceleration gravity and a still-water surface eta0.\n\nnote: Note\nIn DispersiveShallowWater.jl, the Euler equations are only used for computing the full linear dispersion relationomega(k) = sqrtg k tanh(h_0 k)see LinearDispersionRelation and wave_speed. The EulerEquations1D cannot be solved as a system of equations.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.LinearDispersionRelation","page":"DispersiveShallowWater","title":"DispersiveShallowWater.LinearDispersionRelation","text":"LinearDispersionRelation(ref_height)\n\nA struct representing a linear dispersion relation omega(k) of an equation. The reference water height h_0 is given by ref_height. A dispersion relation can be called as disp_rel(equations, k) to compute the wave frequency omega(k) for a given wavenumber k and a set of equations.\n\nSee also wave_speed for computing the wave speed c = omega(k)  k given a linear dispersion relation.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.wave_speed-Tuple{LinearDispersionRelation, Any, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.wave_speed","text":"wave_speed(disp_rel, equations, k; normalize = false)\n\nCompute the wave speed c for a given wavenumber k using the LinearDispersionRelation disp_rel of the equations. The wave speed is given by c = omega(k)  k. If normalize is true, the wave speed is normalized by the shallow water wave speed sqrtg h_0, where g is the gravitational acceleration of the equations and h_0 is the ref_height of the dispersion relation disp_rel.\n\nSee also LinearDispersionRelation.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Mesh","page":"DispersiveShallowWater","title":"Mesh","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.Mesh1D","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Mesh1D","text":"Mesh1D\n\nStruct that holds the information for a simple homogeneous one-dimensional mesh.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.Mesh1D-Tuple{Any, Any, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Mesh1D","text":"Mesh1D(xmin, xmax, N)\n\nCreate a simple homogeneous one-dimensional mesh from xmin to xmax with N nodes.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Boundary-conditions","page":"DispersiveShallowWater","title":"Boundary conditions","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.boundary_condition_periodic","page":"DispersiveShallowWater","title":"DispersiveShallowWater.boundary_condition_periodic","text":"boundary_condition_periodic = DispersiveShallowWater.BoundaryConditionPeriodic()\n\nA singleton struct indicating periodic boundary conditions.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#DispersiveShallowWater.boundary_condition_reflecting","page":"DispersiveShallowWater","title":"DispersiveShallowWater.boundary_condition_reflecting","text":"boundary_condition_reflecting = DispersiveShallowWater.BoundaryConditionReflecting()\n\nA singleton struct indicating reflecting boundary conditions.\n\n\n\n\n\n","category":"constant"},{"location":"ref/#Solver","page":"DispersiveShallowWater","title":"Solver","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.AbstractSolver","page":"DispersiveShallowWater","title":"DispersiveShallowWater.AbstractSolver","text":"AbstractSolver\n\nAn abstract supertype of specific solvers.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.Solver","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Solver","text":"Solver\n\nA struct that holds the summation-by-parts (SBP) operators that are used for the spatial discretization.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.Solver-Tuple{Any, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Solver","text":"Solver(mesh, accuracy_order)\n\nCreate a solver, where the three summation-by-parts (SBP) first-, second-, and third-derivative operators are of accuracy order accuracy_order and associated to the mesh.\n\nwarning: Periodic operators only\nThis constructor creates periodic derivative operators that are only compatible with periodic  boundary conditions. For non-periodic boundary conditions, use the Solver(D1, D2, D3)  constructor with appropriate non-periodic operators (or nothing).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.Solver-Union{Tuple{SummationByPartsOperators.AbstractDerivativeOperator{RealT}}, Tuple{RealT}, Tuple{SummationByPartsOperators.AbstractDerivativeOperator{RealT}, Union{Nothing, AbstractMatrix{RealT}, SummationByPartsOperators.AbstractDerivativeOperator{RealT}}}, Tuple{SummationByPartsOperators.AbstractDerivativeOperator{RealT}, Union{Nothing, AbstractMatrix{RealT}, SummationByPartsOperators.AbstractDerivativeOperator{RealT}}, Union{Nothing, AbstractMatrix{RealT}, SummationByPartsOperators.AbstractDerivativeOperator{RealT}}}} where RealT","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Solver","text":"Solver(D1, D2 = nothing, D3 = nothing)\n\nCreate a solver, where D1 is an AbstractDerivativeOperator from SummationByPartsOperators.jl of first derivative_order, D2 is an AbstractDerivativeOperator  of second derivative_order or an AbstractMatrix, and D3 is an AbstractDerivativeOperator of third derivative_order or an AbstractMatrix. D2 and D3 can also be nothing if that derivative is not used by the discretization. All given summation-by-parts operators should be associated with the same grid.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Semidiscretization","page":"DispersiveShallowWater","title":"Semidiscretization","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.Semidiscretization","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Semidiscretization","text":"Semidiscretization\n\nA struct containing everything needed to describe a spatial semidiscretization of an equation.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.Semidiscretization-NTuple{4, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.Semidiscretization","text":"Semidiscretization(mesh, equations, initial_condition, solver;\n                   source_terms=nothing,\n                   boundary_conditions=boundary_condition_periodic,\n                   RealT=real(solver),\n                   uEltype=RealT,\n                   initial_cache = (tmp1 = Array{RealT}(undef, nnodes(mesh)),\n                                    tmp_partitioned = allocate_coefficients(mesh, equations, solver)))\n\nConstruct a semidiscretization of a PDE.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.jacobian-Tuple{Semidiscretization}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.jacobian","text":"DispersiveShallowWater.jacobian(semi::Semidiscretization;\n                                t = 0.0,\n                                q0 = compute_coefficients(semi.initial_condition, t, semi))\n\nUse the right-hand side operator of the semidiscretization semi and forward mode automatic differentiation to compute the Jacobian J of the semidiscretization semi at the state q0.\n\nwarning: Warning\nThis functionality may not be implemented for all equations.\n\n\n\n\n\n","category":"method"},{"location":"ref/#PolynomialBases.grid-Tuple{Semidiscretization}","page":"DispersiveShallowWater","title":"PolynomialBases.grid","text":"grid(semi)\n\nGet the grid of a semidiscretization.\n\n\n\n\n\n","category":"method"},{"location":"ref/#SummationByPartsOperators.semidiscretize-Tuple{Semidiscretization, Any}","page":"DispersiveShallowWater","title":"SummationByPartsOperators.semidiscretize","text":"semidiscretize(semi::Semidiscretization, tspan)\n\nWrap the semidiscretization semi as an ODE problem in the time interval tspan that can be passed to solve from the SciML ecosystem.\n\n\n\n\n\n","category":"method"},{"location":"ref/#Callbacks","page":"DispersiveShallowWater","title":"Callbacks","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.AnalysisCallback","page":"DispersiveShallowWater","title":"DispersiveShallowWater.AnalysisCallback","text":"AnalysisCallback(semi; interval=0,\n                       extra_analysis_errors=Symbol[],\n                       extra_analysis_integrals=(),\n                       io=stdout)\n\nAnalyze a numerical solution every interval time steps. The L2- and the L∞-norm for each component are computed by default. Additional errors can be computed, e.g. by passing extra_analysis_errors = (:conservation_error,).\n\nFurther scalar functions func in extra_analysis_integrals are applied to the numerical solution and integrated over the computational domain. Some examples for this are entropy, and energy_total. You can also write your own function with the same signature as the examples listed above and pass it via extra_analysis_integrals. The computed errors and intergrals are saved for each timestep and can be obtained by calling errors and integrals.\n\nDuring the Simulation, the AnalysisCallback will print information to io.\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.errors-Union{Tuple{SciMLBase.DiscreteCallback{Condition, Affect!}}, Tuple{Affect!}, Tuple{Condition}} where {Condition, Affect!<:AnalysisCallback}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.errors","text":"errors(analysis_callback)\n\nReturn the computed errors for each timestep as a named tuple. The shape of each entry is (nvariables, ntimesteps).\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.integrals-Union{Tuple{SciMLBase.DiscreteCallback{Condition, Affect!}}, Tuple{Affect!}, Tuple{Condition}} where {Condition, Affect!<:AnalysisCallback}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.integrals","text":"integrals(analysis_callback)\n\nReturn the computed integrals for each timestep as a named tuple.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.tstops-Union{Tuple{SciMLBase.DiscreteCallback{Condition, Affect!}}, Tuple{Affect!}, Tuple{Condition}} where {Condition, Affect!<:AnalysisCallback}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.tstops","text":"tstops(analysis_callback)\n\nReturn the time values that correspond to the saved values of the errors and integrals.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.RelaxationCallback","page":"DispersiveShallowWater","title":"DispersiveShallowWater.RelaxationCallback","text":"RelaxationCallback(invariant)\n\nUse a relaxation method in time in order to exactly preserve the (nonlinear) invariant for a conservative semidiscretization. A possible choice for invariant is invariant = entropy.\n\nReference\n\nHendrik Ranocha, Mohammed Sayyari, Lisandro Dalcin, Matteo Parsani, David I. Ketcheson (2020) Relaxation Runge–Kutta Methods: Fully-Discrete Explicit Entropy-Stable Schemes for the Compressible Euler and Navier–Stokes Equations DOI: 10.1137/19M1263480\n\n\n\n\n\n","category":"type"},{"location":"ref/#DispersiveShallowWater.SummaryCallback","page":"DispersiveShallowWater","title":"DispersiveShallowWater.SummaryCallback","text":"SummaryCallback(io::IO = stdout)\n\nCreate and return a callback that resets the timer at the beginning of a simulation and prints the timer values at the end of the simulation.\n\n\n\n\n\n","category":"type"},{"location":"ref/#Utilities","page":"DispersiveShallowWater","title":"Utilities","text":"","category":"section"},{"location":"ref/#DispersiveShallowWater.convergence_test-Tuple{Module, AbstractString, Any}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.convergence_test","text":"convergence_test([mod::Module=Main,] example::AbstractString, iterations; io::IO = stdout, kwargs...)\nconvergence_test([mod::Module=Main,] example::AbstractString, Ns::AbstractVector; io::IO = stdout, kwargs...)\n\nRun multiple simulations using the setup given in example and compute the experimental order of convergence (EOC) in the L^2 and L^infty norm. If iterations is passed as integer, in each iteration, the resolution of the respective mesh will be doubled. If Ns is passed as vector, the simulations will be run for each value of Ns. Additional keyword arguments kwargs... and the optional module mod are passed directly to trixi_include.\n\nAdjusted from Trixi.jl.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.default_example-Tuple{}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.default_example","text":"default_example()\n\nReturn the path to an example that can be used to quickly see DispersiveShallowWater.jl in action. See also examples_dir and get_examples.\n\nCopied from Trixi.jl.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.examples_dir-Tuple{}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.examples_dir","text":"examples_dir()\n\nReturn the directory where the example files provided with DispersiveShallowWater.jl are located. If DispersiveShallowWater is installed as a regular package (with ]add DispersiveShallowWater), these files are read-only and should not be modified. To find out which files are available, use, e.g., readdir.\n\nCopied from Trixi.jl.\n\nExamples\n\nreaddir(examples_dir())\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.get_examples-Tuple{}","page":"DispersiveShallowWater","title":"DispersiveShallowWater.get_examples","text":"get_examples()\n\nReturn a list of all examples that are provided by DispersiveShallowWater.jl. See also examples_dir and default_example.\n\nCopied from Trixi.jl.\n\n\n\n\n\n","category":"method"},{"location":"ref/#DispersiveShallowWater.@autoinfiltrate","page":"DispersiveShallowWater","title":"DispersiveShallowWater.@autoinfiltrate","text":"@autoinfiltrate\n@autoinfiltrate condition::Bool\n\nInvoke the @infiltrate macro of the package Infiltrator.jl to create a breakpoint for ad-hoc interactive debugging in the REPL. If the optional argument condition is given, the breakpoint is only enabled if condition evaluates to true.\n\nAs opposed to using Infiltrator.@infiltrate directly, this macro does not require Infiltrator.jl to be added as a dependency to DispersiveShallowWater.jl. As a bonus, the macro will also attempt to load the Infiltrator module if it has not yet been loaded manually.\n\nNote: For this macro to work, the Infiltrator.jl package needs to be installed in your current Julia environment stack.\n\nSee also: Infiltrator.jl\n\nwarning: Internal use only\nPlease note that this macro is intended for internal use only. It is not part of the public API of DispersiveShallowWater.jl, and it thus can altered (or be removed) at any time without it being considered a breaking change.\n\n\n\n\n\n","category":"macro"},{"location":"#DispersiveShallowWater.jl","page":"Home","title":"DispersiveShallowWater.jl","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"(Image: Docs-stable) (Image: Docs-dev) (Image: Build Status) (Image: codecov) (Image: Coveralls) (Image: Aqua QA) (Image: License: MIT) (Image: DOI)","category":"page"},{"location":"","page":"Home","title":"Home","text":"DispersiveShallowWater.jl is a Julia package that implements structure-preserving numerical methods for dispersive shallow water models. To date, it provides provably conservative, entropy-conserving and well-balanced numerical schemes for some dispersive shallow water models:","category":"page"},{"location":"","page":"Home","title":"Home","text":"the Korteweg–De Vries (KdV) equation as the prototypical example of an integrable PDE,\nthe Benjamin-Bona-Mahony (BBM) equation, also known as regularized long-wave equation,\nthe BBM-BBM equations with varying bottom topography,\nthe dispersive shallow water model proposed by Magnus Svärd and Henrik Kalisch,\nthe Serre-Green-Naghdi equations in standard and hyperbolic form.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The semidiscretizations are based on summation-by-parts (SBP) operators, which are implemented in SummationByPartsOperators.jl. To obtain fully discrete schemes, the time integration methods from OrdinaryDiffEq.jl are used to solve the resulting ordinary differential equations. Fully discrete entropy-conservative methods can be obtained by using the relaxation method provided by DispersiveShallowWater.jl.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you have not yet installed Julia, then you first need to download Julia. Please follow the instructions for your operating system. DispersiveShallowWater.jl works with Julia v1.10 and newer. DispersiveShallowWater.jl is a registered Julia package. Therefore, you can install it by executing the following commands from the Julia REPL","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Pkg\n\njulia> Pkg.add([\"DispersiveShallowWater\", \"OrdinaryDiffEqTsit5\", \"Plots\"])","category":"page"},{"location":"","page":"Home","title":"Home","text":"In addition, this installs the packages OrdinaryDiffEqTsit5.jl from OrdinaryDiffEq.jl used for time-integration and Plots.jl to visualize the results. If you want to use other time integration methods than Tsit5, you can install the respective subpackage or OrdinaryDiffEq.jl, which will install every available solver. If you want to use other SBP operators than the default operators that DispersiveShallowWater.jl uses, then you also need SummationByPartsOperators.jl, which can be installed running","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> Pkg.add(\"SummationByPartsOperators\")","category":"page"},{"location":"#Usage","page":"Home","title":"Usage","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"In the Julia REPL, first load the package DispersiveShallowWater.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using DispersiveShallowWater","category":"page"},{"location":"","page":"Home","title":"Home","text":"You can run a basic simulation that solves the BBM-BBM equations by executing","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> include(default_example());","category":"page"},{"location":"","page":"Home","title":"Home","text":"The result can be visualized by using the package Plots.jl","category":"page"},{"location":"","page":"Home","title":"Home","text":"julia> using Plots\njulia> plot(semi => sol)","category":"page"},{"location":"","page":"Home","title":"Home","text":"The command plot expects a Pair consisting of a Semidiscretization and an ODESolution. The visualization can also be customized, see the documentation for more details. Other examples can be found in the subdirectory examples/. A list of all examples is returned by running get_examples(). You can pass the filename of one of the examples or your own simulation file to include in order to run it, e.g., include(joinpath(examples_dir(), \"svaerd_kalisch_1d\", \"svaerd_kalisch_1d_dingemans_relaxation.jl\")).","category":"page"},{"location":"#Referencing","page":"Home","title":"Referencing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"You can directly refer to DispersiveShallowWater.jl as","category":"page"},{"location":"","page":"Home","title":"Home","text":"@misc{lampert2025dispersive,\n  title={{D}ispersive{S}hallow{W}ater.jl: {S}tructure-preserving numerical\n         methods for dispersive shallow water models},\n  author={Lampert, Joshua and Wittenstein, Collin and Ranocha, Hendrik},\n  year={2025},\n  howpublished={\\url{https://github.com/NumericalMathematics/DispersiveShallowWater.jl}},\n  doi={10.5281/zenodo.10034636}\n}","category":"page"},{"location":"#Authors","page":"Home","title":"Authors","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The package is developed and maintained by Joshua Lampert (University of Hamburg) with contributions from Hendrik Ranocha (Johannes Gutenberg University Mainz) and Collin Wittenstein (Johannes Gutenberg University Mainz). Some parts of this repository are based on parts of Dispersive-wave-schemes-notebooks. A Broad Class of Conservative Numerical Methods for Dispersive Wave Equations by Hendrik Ranocha, Dimitrios Mitsotakis and David Ketcheson. The code structure is inspired by Trixi.jl.","category":"page"},{"location":"#License-and-contributing","page":"Home","title":"License and contributing","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DispersiveShallowWater.jl is published under the MIT license (see License). We are pleased to accept contributions from everyone, preferably in the form of a PR.","category":"page"}]
}
